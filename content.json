{"meta":{"title":"xluoyu的个人博客|(。・∀・)ノ","subtitle":"个人技术博客","description":"Xluoyu的个人技术博客，记录在前端领域中走过的点点滴滴，xluoyu的记事簿","author":"John Doe","url":"https://xluoyu.github.io/myblog"},"pages":[{"title":"关于我","date":"2019-03-11T16:00:00.000Z","updated":"2020-03-09T11:42:44.755Z","comments":true,"path":"about/index.html","permalink":"https://xluoyu.github.io/myblog/about/index.html","excerpt":"","text":"求职中~ 坐标：北京 Hi~ o(￣▽￣)ブ 基本信息 李政 / 男 / 1997 2018年毕业 / 计算机应用技术专业 个人邮箱： llzz0895@163.com 微信号：moyu_12138 (添加时请备注) 长混迹于 掘金，昵称： xluoyu 一个想要在IT领域实现自己价值的前端er 个人技术栈 精通 HTML5 + CSS3 制作网页，移动端各种屏幕分辨率的适配 以 Vue 为主要开发框架，熟悉 vue 全家桶，习惯以组件化形式开发复杂项目 使用 WePY 框架开发微信小程序，熟悉原生微信小程序开发，目前正在学习 Taro 框架 使用 iView 开发中后台系统，熟悉 Element-UI  接手过 React + dva + Antd 开发的 CRM 系统，在原有基础上进行维护开发 熟练使用原生 JavaScript、ES6、JQuery，能够运用模块化的方式编程 使用 webpack、gulp 进行项目构建，Git、SVN 的项目版本管理 其他技术：Node，koa2，Nginx，Scss，Less，Three.js… 项目介绍1. DueApe辅导平台（学生端） &amp;&amp; 全球IT智慧协同平台（导师端） 两款小程序，基础架构为 WePY + Scss 多个数据列表的搜索、筛选、下拉、上拉的常规开发 登陆 / 注册 状态的鉴定，账号注册，不同账号的权限处理 接入腾讯IM系统，实现导师与学员在平台上的实时沟通并检测聊天内容，屏蔽关键词 学生端开发功能：填表下单、在线支付、优惠券、视频库、视频评论系统、分享拉新、积分提现等 导师端开发功能：在线接单、文档预览、订单结算、个人积分系统、分享拉新、积分提现、系统通知等 2. DueApe管理系统 公司内部中后台系统，基础架构为 Vue全家桶 + iView 复用函数的模块化管理，路由中组件的异步加载 账号注册 / 登陆，不同账号的菜单级权限分配 多张表格的组件化管理，搜索、筛选、分页等常规功能开发 创建、修改、查询等各种表单的组件化处理，使用 eventsBus 实现跨级事件处理 引用 腾讯云、七牛云 实现上传图片、视频功能，上传excel至后台 3. 各类H5页面 以Vue-cli为基础，改造成多页面项目，统一打包发布 使用 Rem 进行移动端适配，axios实现不同环境下的接口请求 使用 CSS3 实现页面内的动画效果 引入 微信API 实现微信环境下的操作 更多 我是一个热爱学习、乐于实践的前端er~，长混迹于掘金阅读技术文章。毕业以来经历过外包公司、创业型公司，前端方面一直是独自探索，希望可以加入有规模的技术团队学到不同方面的技术。 在工作之余我有很多想法，并开发出了许多小Dome，例如： 使用 Three.js 开发的3D地球模型 使用微信小程序云开发的个人小程序 某柴的小账单 （已上线，停止维护…） 使用 eJS + Node + koa2 + MySql 开发的音乐推荐网站 NodeJS开发的文件批量改名小工具…2019年目前有了个新的想法，开发一套基于Vue的UI组件库，正在开发中…. 感谢浏览(●’◡’●)"},{"title":"","date":"2020-03-09T11:42:44.755Z","updated":"2020-03-09T11:42:44.755Z","comments":true,"path":"study/233.html","permalink":"https://xluoyu.github.io/myblog/study/233.html","excerpt":"","text":"Document *{margin: 0;padding: 0;} ul{ display: flex; flex-wrap: wrap; margin: 40px; } li{ list-style: none; width: 200px; height: 200px; background: #eee; margin-bottom: 10px; line-height: 200px; text-align: center; position: relative; } li:not(:last-child):after{ content: ''; position: absolute; width: 1px; height: 100px; background: #ccc; right: 0; top: 50px; } li[data-after=\"none\"]::after{ display: none } /* li:not(:last-child){ border-right: 1px solid #ccc; } */ 1 2 3 4 5 var oli = document.querySelectorAll('li') var index = getIndex(oli) var getList = document.querySelectorAll('li:nth-child('+index+'n)') for (var z=0; z< getList.length; z++) { getList[z].setAttribute('data-after', 'none') } function getIndex(oli) { var arr = [] var index = 0 for (var i=0; i"},{"title":"","date":"2020-03-09T11:42:44.755Z","updated":"2020-03-09T11:42:44.755Z","comments":true,"path":"study/css.html","permalink":"https://xluoyu.github.io/myblog/study/css.html","excerpt":"","text":"Document div{ margin: 40px; } #star{ margin: 50px 0; position: relative; color: red; width: 0; border-right: 100px solid transparent; border-bottom: 70px solid red; border-left: 100px solid transparent; transform: rotate(35deg) } #star::before{ content: ''; border-bottom: 80px solid red; border-left: 30px solid transparent; border-right: 30px solid transparent; position: absolute; top: -45px; left: -62px; transform: rotate(-35deg) } #star::after{ position: absolute; color: red; top: 3px; left: -105px; border-right: 100px solid transparent; border-bottom: 70px solid red; border-left: 100px solid transparent; transform: rotate(-70deg); content: ''; } #heart { position: relative; width: 100px; height: 90px; } #heart:before, #heart:after { position: absolute; content: \"\"; left: 50px; top: 0; width: 50px; height: 80px; background: red; border-radius: 50px 50px 0 0; transform: rotate(-45deg); transform-origin: 0 100%; } #heart:after { left: 0; transform: rotate(45deg); transform-origin: 100% 100%; } #infinity { position: relative; width: 212px; height: 100px; box-sizing: content-box; } #infinity:before, #infinity:after { content: \"\"; box-sizing: content-box; position: absolute; top: 0; left: 0; width: 60px; height: 60px; border: 20px solid red; border-radius: 50px 50px 0 50px; transform: rotate(-45deg); } #infinity:after { left: auto; right: 0; border-radius: 50px 50px 50px 0; transform: rotate(45deg); } #burst-12 { background: red; width: 80px; height: 80px; position: relative; text-align: center; } #burst-12:before, #burst-12:after { content: \"\"; position: absolute; top: 0; left: 0; height: 80px; width: 80px; background: red; } #burst-12:before { transform: rotate(30deg); } #burst-12:after { transform: rotate(60deg); } #yin-yang { width: 96px; height: 48px; background: #eee; border-color: red; border-style: solid; border-width: 2px 2px 50px 2px; border-radius: 100%; position: relative; } #yin-yang:before { content: \"\"; position: absolute; top: 50%; left: 0; background: #fff; border: 18px solid red; border-radius: 100%; width: 12px; height: 12px; } #yin-yang:after { content: \"\"; position: absolute; top: 50%; left: 50%; background: red; border: 18px solid #eee; border-radius: 100%; width: 12px; height: 12px; }"},{"title":"","date":"2020-04-09T04:45:04.747Z","updated":"2020-04-09T04:45:04.747Z","comments":true,"path":"study/definePrototype.html","permalink":"https://xluoyu.github.io/myblog/study/definePrototype.html","excerpt":"","text":"Document class Vue { constructor(options) { this.options = options this.$el = document.querySelector(options.el) this.$data = options.data this.$methods = options.methods this._directive = {} this.Observer(this.$data) this.Compile(this.$el) } Observer(data) { for (let key in data) { this._directive[key] = [] let val = data[key] let Wacher = this._directive[key] Object.defineProperty(data, key, { get: () => { return val }, set: (newVal) => { val = newVal Wacher.forEach(element => { element.update() }) } }) } } Compile(el) { let nodes = el.children for (let i = 0; i < nodes.length; i++) { let node = nodes[i] if (node.children.length) { this.Compile(node) } if (node.hasAttribute('v-text')) { let attrVal = node.getAttribute('v-text') this._directive[attrVal].push(new Watcher(node, this, attrVal, 'innerHTML')) } if (node.hasAttribute('v-model')) { let attrVal = node.getAttribute('v-model') this._directive[attrVal].push(new Watcher(node, this, attrVal, 'value')) node.addEventListener('input', (e) => { this.$data[attrVal] = e.target.value }) } if (node.hasAttribute('@click')) { let attrVal = node.getAttribute('@click') let arg = attrVal.match(/\\(.+?\\)/g)[0] let func = attrVal.match(/^.+?\\(/g)[0] arg = arg.substring(1, arg.length - 1) func = func.substring(0, func.length - 1) if (arg) { arg = arg.split(',') } else { arg = [] } node.addEventListener('click', () => { this.$methods[func].call(this, [...arg]) }, false) } } } } class Watcher { constructor(el, vm, data, exp) { this.el = el this.vm = vm this.data = data this.exp = exp this.update() } update() { this.el[this.exp] = this.vm.$data[this.data] } } 点击 const app = new Vue({ el: '#app', data: { text1: '第一个', text2: '第二个' }, methods: { clickBtn(data) { console.log('点击输出：' + data) this.child() }, child() { console.log('这是child') } } })"},{"title":"","date":"2020-03-09T11:42:44.755Z","updated":"2020-03-09T11:42:44.755Z","comments":true,"path":"study/lazyLoad.html","permalink":"https://xluoyu.github.io/myblog/study/lazyLoad.html","excerpt":"","text":"图片懒加载 body,html,ul, li, img{margin: 0;padding: 0} li{ list-style: none; width: 500px; height: 500px; margin: 50px auto; } img{ width: 100%; height: 100%; object-fit: cover; } div{ width: 100%; height: 100px; } function lazyload() { var imgArr = setArr(document.querySelectorAll('.lazyload-img')) var imgLength = imgArr.length var viewHeight = document.body.clientHeight // 窗口可视高度 return function() { if (!imgLength) return // imgLength == 0 结束 for (var i=0; i< imgLength;) { // 移除i++ var imgTop = imgArr[i].getBoundingClientRect().top // 元素距离视口顶部高度 var imgBottom = imgArr[i].getBoundingClientRect().bottom // 元素距离视口底部高度 // 判断条件: imgTop小于视口高度且大于等于0 或者 imgBottom小于视口高度且大于等于0 if (imgTop = 0 || imgBottom =0) { // 将 data-src 的值赋给 src imgArr[i].setAttribute('src', imgArr[i].getAttribute('data-src')) // 图片展示之后在数组中将其移除 imgArr.splice(i, 1) imgLength-- } else { // 不满足条件 i++ } } } } let io = new IntersectionObserver(function (e) { e.forEach((item) => { if (item.isIntersecting) { item.target.src = item.target.dataset.src io.unobserve(item.target) } }) }) let imgArr = document.querySelectorAll('.lazyload-img') imgArr.forEach(item => { io.observe(item) }) /** * 节点列表改为数组 * domList -> 节点列表 */ function setArr(domList) { var arr = [] for(var i = 0, n; n = domList[i]; ++i) { arr.push(n) } return arr } /** * 节流 * func -> 函数 * delay -> 时间(毫秒) */ function throttle(func, delay) { var prev = Date.now() return function () { var content = this var args = arguments var now = Date.now() if (now - prev >= delay) { func.apply(content, args) prev = Date.now() } } } // var loadImg = lazyload() // loadImg() // window.addEventListener('scroll', throttle(loadImg, 200))"},{"title":"","date":"2020-03-09T11:42:44.755Z","updated":"2020-03-09T11:42:44.755Z","comments":true,"path":"study/server.js","permalink":"https://xluoyu.github.io/myblog/study/server.js","excerpt":"","text":"\"use strict\"; //加载所需要的模块 var http = require('http'); var url = require('url'); var fs = require('fs'); var path = require('path'); var cp = require('child_process'); //创建服务 var httpServer = http.createServer(processRequest); var port = 3030; //指定一个监听的接口 httpServer.listen(port, function() { console.log(`app is running at port:${port}`); console.log(`url: http://localhost:${port}`); cp.exec(`explorer http://localhost:${port}`, function () { }); }); //响应请求的函数 function processRequest (request, response) { //mime类型 var mime = { \"css\": \"text/css\", \"gif\": \"image/gif\", \"html\": \"text/html\", \"ico\": \"image/x-icon\", \"jpeg\": \"image/jpeg\", \"jpg\": \"image/jpeg\", \"js\": \"text/javascript\", \"json\": \"application/json\", \"pdf\": \"application/pdf\", \"png\": \"image/png\", \"svg\": \"image/svg+xml\", \"swf\": \"application/x-shockwave-flash\", \"tiff\": \"image/tiff\", \"txt\": \"text/plain\", \"wav\": \"audio/x-wav\", \"wma\": \"audio/x-ms-wma\", \"wmv\": \"video/x-ms-wmv\", \"xml\": \"text/xml\" }; //request里面切出标识符字符串 var requestUrl = request.url; //url模块的parse方法 接受一个字符串，返回一个url对象,切出来路径 var pathName = url.parse(requestUrl).pathname; //对路径解码，防止中文乱码 var pathName = decodeURI(pathName); //解决301重定向问题，如果pathname没以/结尾，并且没有扩展名 if (!pathName.endsWith('/') && path.extname(pathName) === '') { pathName += '/'; var redirect = \"http://\" + request.headers.host + pathName; response.writeHead(301, { location: redirect }); //response.end方法用来回应完成后关闭本次对话，也可以写入HTTP回应的具体内容。 response.end(); } //获取资源文件的绝对路径 var filePath = path.resolve(__dirname + pathName); console.log(filePath); //获取对应文件的文档类型 //我们通过path.extname来获取文件的后缀名。由于extname返回值包含”.”，所以通过slice方法来剔除掉”.”， //对于没有后缀名的文件，我们一律认为是unknown。 var ext = path.extname(pathName); ext = ext ? ext.slice(1) : 'unknown'; //未知的类型一律用\"text/plain\"类型 var contentType = mime[ext] || \"text/plain\"; fs.stat(filePath, (err, stats) => { if (err) { response.writeHead(404, { \"content-type\": \"text/html\" }); response.end(\"404 Not Found\"); } //没出错 并且文件存在 if (!err && stats.isFile()) { readFile(filePath, contentType); } //如果路径是目录 if (!err && stats.isDirectory()) { var html = \"\"; //读取该路径下文件 fs.readdir(filePath, (err, files) => { if (err) { console.log(\"读取路径失败！\"); } else { //做成一个链接表，方便用户访问 var flag = false; for (var file of files) { //如果在目录下找到index.html，直接读取这个文件 if (file === \"index.html\") { readFile(filePath + (filePath[filePath.length-1]=='/' ? '' : '/') + 'index.html', \"text/html\"); flag = true; break; }; html += `${file}`; } if(!flag) { html += ''; response.writeHead(200, { \"content-type\": \"text/html\" }); response.end(html); } } }); } //读取文件的函数 function readFile(filePath, contentType){ response.writeHead(200, { \"content-type\": contentType }); //建立流对象，读文件 var stream = fs.createReadStream(filePath); //错误处理 stream.on('error', function() { response.writeHead(500, { \"content-type\": contentType }); response.end(\"500 Server Error\"); }); //读取文件 stream.pipe(response); } }); }"},{"title":"","date":"2020-03-09T11:42:44.755Z","updated":"2020-03-09T11:42:44.755Z","comments":true,"path":"study/this.html","permalink":"https://xluoyu.github.io/myblog/study/this.html","excerpt":"","text":"Document var name = 'window' // function foo() { // console.log(this.name) // window // } // (function (foo) { // var name = 'func'; // foo() // })(foo) // var test = { // 'name': 'test', // foo: function() { // console.log(this.name) // } // }; // var newFoo = new test; // newFoo() // function test(data) { // var name = data || 'test' // console.log(this) // }; // test(); // var ob = new test('ob'); // ob; function Product(name, price) { this.name = name; this.price = price; } function Food(name, price) { Product.call(this, name, price); this.category = 'food'; } console.log(new Food('cheese', 5).name);"}],"posts":[{"title":"关于vue的原理","slug":"面试题/关于vue的原理","date":"2020-04-03T05:14:19.000Z","updated":"2020-04-09T05:32:07.380Z","comments":true,"path":"面试题/关于vue的原理/","link":"","permalink":"https://xluoyu.github.io/myblog/面试题/关于vue的原理/","excerpt":"关于vue的原理","text":"关于vue的原理 首先vue对于数据绑定使用的是数据劫持结合发布订阅模式，在2.6版本之前是通过Object.definePrototype来劫持各个属性的setter和getter方法，在数据变动时发布消息给订阅者，出发相应的回调。 Observer将需要劫持的对象进行一个递归遍历，给每个属性都加上setter和getter，这样当数据改变时就会触发他的setter，就能监听到数据变化了。然后就是实现一个消息订阅器，它可以搜集订阅者，并且触发他们的update函数。在劫持数据触发setter时调用消息订阅器的notify通知函数让这个数据的订阅者们都触发update Compilevue实现了一个模板解析器，能够对模板中的v-bind、v-on之类的指令和表达式进行解析，将模板中的变量替换成数据，然后初始化渲染页面，并且对解析出来的变量创建订阅者和他的update方法，将订阅者添加进他所属的数据子类也就是属性订阅器中，这样在数据变化时就可以调用到这个变量的update，实现数据绑定。对于模板解析器 watcherWatcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是:1、在自身实例化时往属性订阅器(dep)里面添加自己2、自身必须有一个update()方法3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。","categories":[{"name":"日常笔记","slug":"日常笔记","permalink":"https://xluoyu.github.io/myblog/categories/日常笔记/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://xluoyu.github.io/myblog/tags/面试/"}]},{"title":"面试题","slug":"面试题/day1","date":"2020-04-03T05:14:19.000Z","updated":"2020-04-05T06:08:35.305Z","comments":true,"path":"面试题/day1/","link":"","permalink":"https://xluoyu.github.io/myblog/面试题/day1/","excerpt":"基础面试问题1","text":"基础面试问题1 1.css兼容性有哪几种处理方案 由于浏览器厂商太多，出品了各种浏览器，不过现在还是chrome浏览器的内核占比比较多，所以先是以chrome为主，然后去兼容IE之类的浏览器内核。 css初始化。因为每个浏览器的css默认样式不尽相同，所以最有效的办法是将所使用到的一些样式添加上默认值，比如 12345678910111213141516html, body, div, img, h1 - h6, ul, li, ol, p&#123; margin: 0; padding: 0; font-family: &apos;微软雅黑&apos;, font-size: 14px&#125;a&#123; text-decoration: none&#125;img&#123; border: none; display: block;&#125;ul, li, ol&#123; list-style: none;&#125; 浏览器的私有属性。在某些css属性前添加前缀，如-webkit-, -moz-。一个一个加这些很麻烦，所以可以引入自动化插件：Autoprefixer，在webpack或者gulp工具中加入Autoprefixer，就不用关心加前缀的事了。2.怎么理解margin合并/越界/塌陷margin合并就是指两个垂直外边距相遇时，只会存在外边距较大的那个。越界是父子标签都有垂直方向的margin，只会存在较大的那个。要解决这种现象，可以将他们放置在不同的BFC中，比如给其中一个套上一个有overflow: hidden属性的标签，形成两个BFC，或者是修改margin，改为同一方向。3.js的继承方式有哪些 原型链继承123function parent()&#123;&#125;function child()&#123;&#125;child.prototype = new parent() 通过把父级函数赋值到子函数的原型链上实现继承缺点： 12345678function parent () &#123; this.type = [&apos;html&apos;, &apos;css&apos;]&#125;son1 = new child()son2 = new child()son1.type.push(&apos;vue&apos;)console.log(son1.type) // [&apos;html&apos;, &apos;css&apos;, &apos;vue&apos;]console.log(son2.type) // [&apos;html&apos;, &apos;css&apos;, &apos;vue&apos;] 子函数上的原型对象都指向父函数，导致所有子函数实例化后都共享原型对象的属性和方法 构造函数继承123456789101112function parent (name) &#123; this.name = name this.type = [&apos;html&apos;, &apos;css&apos;]&#125;function child (name) &#123; parent.call(this, name)&#125;let son1 = new child()let son2 = new child()son1.type.push(&apos;vue&apos;)console.log(son1.type) // [&apos;html&apos;, &apos;css&apos;, &apos;vue&apos;]console.log(son2.type) // [&apos;html&apos;, &apos;css&apos;] 通过构造函数call方法进行继承优点： 实例化对象的独立性；还可以给实例化对象添加参数缺点： call方法仅调用了父级函数的属性及方法，没有调用原型对象的方法 组合继承1234function child () &#123; parent.call(this)&#125;child.prototype = new parent() 把上面两个组合在一起优点：基本满足了js的继承，比较常用；缺点：调用了两次父级函数 ES6继承123456789101112131415class Parent2 &#123; constructor(name) &#123; this.name = name &#125; say () &#123; console.log(this.name) &#125;&#125;class Child2 extends Parent2 &#123; constructor (name) &#123; super(name) &#125;&#125;let test = new Child2(&apos;test&apos;)test.say() // test 子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。 4.深拷贝怎么实现浅拷贝： 创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。 深拷贝： 将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象 简便法1JSON.parse(JSON.stringify(obj)) 这种方法是最常用的原理： 用JSON.stringify将对象转成JSON字符串，再用JSON.parse()把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝缺点：无法拷贝函数 递归","categories":[{"name":"日常笔记","slug":"日常笔记","permalink":"https://xluoyu.github.io/myblog/categories/日常笔记/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://xluoyu.github.io/myblog/tags/面试/"}]},{"title":"vue的基础面试题","slug":"面试题/vue基础面试题","date":"2020-04-03T05:14:19.000Z","updated":"2020-04-09T10:01:18.182Z","comments":true,"path":"面试题/vue基础面试题/","link":"","permalink":"https://xluoyu.github.io/myblog/面试题/vue基础面试题/","excerpt":"vue的基础面试题","text":"vue的基础面试题","categories":[{"name":"日常笔记","slug":"日常笔记","permalink":"https://xluoyu.github.io/myblog/categories/日常笔记/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://xluoyu.github.io/myblog/tags/面试/"}]},{"title":"项目优化","slug":"日常笔记/关于后台项目的优化","date":"2020-04-03T05:14:19.000Z","updated":"2020-04-07T08:10:24.359Z","comments":true,"path":"日常笔记/关于后台项目的优化/","link":"","permalink":"https://xluoyu.github.io/myblog/日常笔记/关于后台项目的优化/","excerpt":"关于后台项目的点","text":"关于后台项目的点 1. 组件优化因为项目中含有大量的表格、筛选、弹框表单，所以对iview的一些组件进行了更贴合项目的组件封装。拿表格这一块举例，将常用到的是iview的表格组件、分页组件，还有自己实现的筛选功能组件，将这些组件混合成一个满足表格功能模块的大组件，使用的时候只需要传入表头、获取数据的事件、需要筛选的字段就可以。该组件对于这个项目来说复用性非常高。 问题： 组件通信 父子组件之间直接使用prop和事件event尽享互动传递； 2. 路由权限管理3. 第三方插件优化减小lodash体积，","categories":[{"name":"日常笔记","slug":"日常笔记","permalink":"https://xluoyu.github.io/myblog/categories/日常笔记/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://xluoyu.github.io/myblog/tags/面试/"}]},{"title":"实现极简版Vue(defineProptotype)","slug":"JavaScript/实现极简版Vue","date":"2019-05-30T08:12:17.000Z","updated":"2020-03-09T11:42:44.755Z","comments":true,"path":"JavaScript/实现极简版Vue/","link":"","permalink":"https://xluoyu.github.io/myblog/JavaScript/实现极简版Vue/","excerpt":"基于definePrototype实现极简版Vue 实现功能: 数据绑定、双向绑定、methods","text":"基于definePrototype实现极简版Vue 实现功能: 数据绑定、双向绑定、methods 最终结果: 项目预览(可直接查看源代码) 页面结构12345678910111213141516171819202122232425&lt;div id=&quot;app&quot;&gt; &lt;p v-text=&apos;text1&apos;&gt;&lt;/p&gt; &lt;p v-text=&apos;text2&apos;&gt;&lt;/p&gt; &lt;input type=&quot;text&quot; v-model=&apos;text1&apos;&gt; &lt;input type=&quot;text&quot; v-model=&apos;text2&apos;&gt; &lt;button @click=&apos;clickBtn(hello)&apos;&gt;点击&lt;/button&gt;&lt;/div&gt;&lt;script&gt;const app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; text1: &apos;第一个&apos;, text2: &apos;第二个&apos; &#125;, methods: &#123; clickBtn(data) &#123; console.log(&apos;点击输出：&apos; + data) this.child() &#125;, child() &#123; console.log(&apos;这是child&apos;) &#125; &#125;&#125;)&lt;/script&gt; 构建Class Vue先写出Vue基础板块1234567891011121314151617181920212223Class Vue&#123; constructor(options) &#123; /** * 将传入的参数绑定到Vue上 */ this.$el = document.querySelector(options.el) this.$data = options.data this.$methods = options.methods this._directive = &#123;&#125; // 发布订阅库 this.Observer(this.$data) // 数据劫持 this.Compile(this.$el) // 解析模板 &#125; Observer(data) &#123; &#125; Compile(el) &#123; &#125;&#125; 数据劫持我们需要使用defineProptotype来重新设置data中每一项的get和set123456789101112131415161718Observer(data) &#123; for (let key in data) &#123; let val = data[key] // 储存值 this._directive[key] = [] // 初始化订阅器 /** * 截取data */ Object.definePrototype(data, key, &#123; get: () =&gt; &#123; return val &#125;, set: (newVal) =&gt; &#123; if (val === newVal) return val = newVal &#125; &#125;) &#125;&#125; 解析模板我们要从$el的一层层子元素中解析出标签中绑定的元素1234567891011121314151617181920212223242526272829303132333435Compile(el) &#123; let nodes = el.children // 获取el的所有子元素 for (let i=0; i &lt; nodes.length; i++) &#123; let node = nodes[i] // 如果第一层子元素中还有子元素，继续递归解析 if (node.children.length) &#123; this.Compile(node) &#125; // `v-text` if (node.hasAttribute(&apos;v-text&apos;)) &#123; let attrVal = node.getAttribute(&apos;v-text&apos;) // 获取值 /** * 在发布订阅中添加一个观察者 * 该观察者绑定了node元素，并有一个update函数用于更新所需字段 */ this._directive[attrVal].push(new Watcher) &#125; // v-model if (node.hasAttribute(&apos;v-model&apos;)) &#123; let attrVal = node.getAttribute(&apos;v-model&apos;) // 获取值 /** * 在发布订阅中添加一个观察者 */ this._directive[attrVal].push(new Watcher) // 因为model是双向绑定，需要监听它的值来进行操作 node.addEventListener(&apos;input&apos;, (e) =&gt; &#123; // 修改data中存放的值 this.$data[attrVal] = e.target.value &#125;, false) &#125; &#125;&#125; 观察者观察者用以绑定含有某字段的dom元素，并提供一个update方法我们改变一个dom元素的值需要12el.innerHTML = valuedom元素, 操作指令, 值 所以传入参数为 el = dom元素 vm = this =&gt; 指向Vue类 exp = 操作指令 data = dom节点绑定的元素 如text11234567891011121314151617Class Watcher() &#123; constructor(el, vm, exp, data) &#123; // 绑定到类上 this.el = el this.vm = vm this.exp = exp this.data = data // 初始化更新 this.update() &#125; update() &#123; this.el[exp] = this.vm.$data[this.data] // el.innerHTML = value &#125;&#125; 完整代码可查看项目预览(可直接查看源代码)","categories":[{"name":"JS基础深入","slug":"JS基础深入","permalink":"https://xluoyu.github.io/myblog/categories/JS基础深入/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xluoyu.github.io/myblog/tags/JavaScript/"}]},{"title":"Node调用微信js-sdk","slug":"日常笔记/Node调用微信js-sdk","date":"2019-05-30T08:12:17.000Z","updated":"2020-03-09T11:42:44.755Z","comments":true,"path":"日常笔记/Node调用微信js-sdk/","link":"","permalink":"https://xluoyu.github.io/myblog/日常笔记/Node调用微信js-sdk/","excerpt":"使用Node调用微信js-sdk，爬坑笔记","text":"使用Node调用微信js-sdk，爬坑笔记 需求使用node做微信后台，制作一个简单的微信转发祈福页面 效果图： 主要难点： 页面title的数字计数 微信Api的调用 1. 用户数量计数使用数字来记录用户的访问量，对于计数器而言在网上可以找到很多，这里就是用了本博客中使用的 不蒜子 在做ip计数 页面结构如下12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,user-scalable=no&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;转发这位考神，保佑你逢考必过！考神附体！考的全会！蒙的全对！&quot;&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;!-- 引入不蒜子 --&gt;&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;&lt;!-- 引入微信api --&gt;&lt;script src=&quot;http://res2.wx.qq.com/open/js/jweixin-1.4.0.js&quot;&gt;&lt;/script&gt;&lt;style&gt;html,body,img,span&#123; margin: 0; padding: 0;&#125;img&#123; width: 100%; display: block;&#125;&lt;/style&gt;&lt;body&gt; &lt;img src=&quot;./img.png&quot; alt=&quot;&quot;&gt; &lt;!-- 不蒜子 --&gt; &lt;span id=&quot;busuanzi_value_site_pv&quot; style=&quot;display: none&quot;&gt;&lt;/span&gt;&lt;/body&gt;&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;...&lt;/script&gt;&lt;/html&gt; 相关JS1234567891011121314var script = document.querySelectorAll(&apos;script&apos;)[0] // 引用不蒜子的script标签var count = 0 // 计数储存script.onload = setTitle()function setTitle() &#123; var number = document.querySelector(&apos;#busuanzi_value_site_pv&apos;).innerHTML // 获取不蒜子计数 if (number) &#123; document.title = &apos;我是第&apos; + number + &apos;个被考神保佑的幸运儿，逢考必过！&apos; // 修改title document.body.appendChild(i); count = number &#125; else &#123; setTimeout(setTitle, 50) // 由于需要网络请求，在获取计数之前反复验证数字 &#125;&#125; 由于微信浏览器的限制，页面加载完毕之后title无法更改，需要创建一个iframe来处理，代码如下 12345678var i = document.createElement(&apos;iframe&apos;); i.src = &apos;https://www.baidu.com/favicon.ico&apos;; i.style.display = &apos;none&apos;; i.onload = function() &#123; setTimeout(function()&#123; i.remove(); 移除 &#125;, 1) &#125; 在修改title后插入标签12345if (number) &#123; document.title = &apos;我是第&apos; + number + &apos;个被考神保佑的幸运儿，逢考必过！&apos; // 修改title document.body.appendChild(i); // 插入iframe count = number &#125; easy~ 2. 使用微信API之前使用微信API就要涉及到关于微信公众号等一些账号问题，可在微信公众平台自行注册。如果仅用于测试，需要注册测试账号接口测试号申请 有了相关账号之后就可以得到 appID 和 appsecret 用于认证，调用微信接口时还需要安全域名 坑！ 不需要填写http://或https://，在本地测试也不要使用端口号，仅支持80(http)和443(https) 之后的相关开发就可以根据官方文档继续进行 引入js文件：http://res.wx.qq.com/open/js/jweixin-1.4.0.js ， 前端调用后端接口，开始进行权限认证 获取access_token，并缓存 根据签名算法，获取签名，并缓存 后端将接口配置所需的相关信息返回给前端 注入配置信息 12345678wx.config(&#123; debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。 appId: &apos;&apos;, // 必填，公众号的唯一标识 timestamp: , // 必填，生成签名的时间戳 nonceStr: &apos;&apos;, // 必填，生成签名的随机串 signature: &apos;&apos;,// 必填，签名 jsApiList: [] // 必填，需要使用的JS接口列表&#125;); 通过ready接口处理成功验证 123wx.ready(function()&#123; // config信息验证后会执行ready方法，所有接口调用都必须在config接口获得结果之后，config是一个客户端的异步操作，所以如果需要在页面加载时就调用相关接口，则须把相关接口放在ready函数中调用来确保正确执行。对于用户触发时才调用的接口，则可以直接调用，不需要放在ready函数中。&#125;); 3. 后端开发这里简单使用的koa2进行开发123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354... //省略const sha1 = require(&apos;node-sha1&apos;) // sha1加密算法// 注册公众平台/测试账号后得到的信息const AppID = &apos;wx12345647897987&apos;const APPSECRET = &apos;f0200721fa1324z2123456789&apos;// 获取access_token的地址const accessToken = `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=$&#123;AppID&#125;&amp;secret=$&#123;APPSECRET&#125;`// 缓存 accessToken 和 ticketlet cache = &#123; accessToken: &#123; access_token: &apos;&apos;, time: &apos;&apos; &#125;, ticket: &#123; ticket: &apos;&apos;, time: &apos;&apos; &#125;&#125;// 缓存时间 2小时const timeRange = 2 * 60 * 60/** * 获取权限配置所需信息 * url =&gt; String 使用接口的页面地址 */router.get(&apos;/getData&apos;, async(ctx, next) =&gt; &#123; // 获取access_token const &#123; access_token &#125; = await getAccessToken().then(res =&gt; res) // 获取ticket const &#123; ticket &#125; = await getTicket(access_token).then(res =&gt; res) // 随机字符串 const noncestr = Math.random().toString(36).substr(2) // 时间戳 精确到秒! const timestamp = Math.round(new Date().getTime()/1000).toString() // 接口的请求地址，需前端传入 const url = ctx.query.url // 组合成待加密的字符串 const string = `jsapi_ticket=$&#123;ticket&#125;&amp;noncestr=$&#123;noncestr&#125;&amp;timestamp=$&#123;timestamp&#125;&amp;url=$&#123;url&#125;` // 使用 sha1 算法加密 const signature = sha1(string) // 向前端返回所需信息 ctx.body = &#123; status: 200, data: &#123; appId: AppID, timestamp: timestamp, // 时间戳 noncestr: noncestr, // 随机字符串 signature: signature // 签名 &#125; &#125;&#125;) 由于每日获取access_token 和 ticket 的次数有限，所以需要做缓存处理，更新时间为2小时 获取access_token1234567891011121314151617181920212223async function getAccessToken() &#123; return new Promise((resolve, reject) =&gt; &#123; // 判断access_token的可用时间，第一次调用函数需要设置时间，未超过两小时则直接返回 if (!cache.accessToken.time) &#123; cache.accessToken.time = Math.round(new Date().getTime()/1000).toString() &#125; else if (cache.accessToken.access_token &amp;&amp; Math.round(new Date().getTime()/1000).toString() - cache.accessToken.time &lt; timeRange) &#123; resolve(cache.accessToken) // 未超过缓存时间时直接返回值 return &#125; // 请求access_token https.get(accessToken, (res) =&gt; &#123; var ddd = &quot;&quot;; res.on(&apos;data&apos;, (d) =&gt; &#123; ddd += d; &#125;); res.on(&apos;end&apos;, () =&gt; &#123; var obj = JSON.parse(ddd); cache.accessToken.access_token = obj.access_token resolve(obj) &#125;) &#125;) &#125;)&#125; 获取ticket12345678910111213141516171819202122232425async function getTicket(access_token) &#123; return new Promise((resolve, reject) =&gt; &#123; // 缓存原理同上 if (!cache.ticket.time) &#123; cache.ticket.time = Math.round(new Date().getTime()/1000).toString() &#125; else if (cache.ticket.ticket &amp;&amp; Math.round(new Date().getTime()/1000).toString() - cache.ticket.time &lt; timeRange) &#123; resolve(cache.ticket) return &#125; // 根据传入的access_token，组合请求地址 const ticketUrl = `https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=$&#123;access_token&#125;&amp;type=jsapi` // 请求ticket https.get(ticketUrl, (res) =&gt; &#123; var ddd = &quot;&quot;; res.on(&apos;data&apos;, (d) =&gt; &#123; ddd += d; &#125;); res.on(&apos;end&apos;, () =&gt; &#123; var obj = JSON.parse(ddd); cache.ticket.ticket = obj.ticket resolve(obj) &#125;) &#125;) &#125;)&#125; 4. 前端开发调用后端接口获取所需信息12345678910111213141516// 传入当前页面地址function getData() &#123; $.get(&apos;/getData&apos;, &#123;url: location.href.split(&apos;#&apos;)[0]&#125;, function (res) &#123; // 成功回调 // 进行微信权限配置 wx.config(&#123; debug: true, appId: res.data.appId, timestamp: res.data.timestamp, nonceStr: res.data.noncestr, signature: res.data.signature, jsApiList: [&apos;updateAppMessageShareData&apos;, &apos;updateTimelineShareData&apos;] &#125;) setWx() &#125;)&#125; 使用微信Api1234567891011121314151617181920212223242526function setWx() &#123; wx.ready(function () &#123; // 分享给朋友 wx.updateAppMessageShareData(&#123; title: &apos;我是第&apos; + count + &apos;个被考神保佑的幸运儿，逢考必过！&apos;, // 分享标题 desc: &apos;转发这位考神，保佑你逢考必过！考神附体！考的全会！蒙的全对！&apos;, // 分享描述 link: window.location.href, // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致 imgUrl: &apos;http://file.rabbitpre.com/default.png&apos;, // 分享图标 success: function () &#123; // 设置成功 console.log(count) &#125; &#125;) // 分享到朋友圈 wx.updateTimelineShareData(&#123; title: &apos;我是第&apos; + count + &apos;个被考神保佑的幸运儿，逢考必过！&apos;, // 分享标题 desc: &apos;转发这位考神，保佑你逢考必过！考神附体！考的全会！蒙的全对！&apos;, // 分享描述 link: window.location.href, // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致 imgUrl: &apos;http://file.rabbitpre.com/default.png&apos;, // 分享图标 success: function () &#123; // 设置成功 console.log(count) &#125; &#125;) &#125;);&#125; 5. 遇到的坑 签名有误主要原因：时间戳要精确到秒（不是毫秒！） 安全域名主要原因：不需要写 http:// 或 https://, 也不要端口！ 微信开发工具的二次请求将请求后端接口的函数在全局调用时会在开发工具中触发两次，但在chrome中不会，BUG原因尚不明确，我将函数的触发位置放在了修改title之后，表现为123456if (number) &#123; document.title = &apos;我是第&apos; + number + &apos;个被考神保佑的幸运儿，逢考必过！&apos; document.body.appendChild(i); count = number getData()&#125; 6. 工具推荐在公司制作这个小页面还需要涉及到微信Api、和后台交互，略有些繁琐，我们大可使用H5的一些制作工具，这里推荐兔展平台，其中就有这个用户计数和小卡片分享功能，不需要敲一行代码就可以制作完成，很方便~","categories":[{"name":"日常笔记","slug":"日常笔记","permalink":"https://xluoyu.github.io/myblog/categories/日常笔记/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://xluoyu.github.io/myblog/tags/node-js/"}]},{"title":"记录webapp项目开发（一）","slug":"日常笔记/记录webapp项目开发（一）","date":"2019-05-30T08:12:17.000Z","updated":"2020-03-09T11:42:44.755Z","comments":true,"path":"日常笔记/记录webapp项目开发（一）/","link":"","permalink":"https://xluoyu.github.io/myblog/日常笔记/记录webapp项目开发（一）/","excerpt":"合作开发一个webapp，记录一下开发中所用到的知识点一、起步","text":"合作开发一个webapp，记录一下开发中所用到的知识点一、起步 1. 项目框架本项目由vue全家桶 + axios + vux + less 构建 vux是基于WeUI和Vue(2.x)开发的移动端UI组件库，主要服务于微信页面vux: https://doc.vux.li/zh-CN/ 注意: 在项目中引入polyfill以保证代码的兼容新1&lt;script src=&quot;https://cdn.bootcss.com/babel-polyfill/6.23.0/polyfill.min.js&quot;&gt;&lt;/script&gt; 项目结构123456789101112131415-src |- assets |- components |- fetch | |- axios.js // axios 配置文件 | |- api.js |- router |- store | |- index.js | |- module |- style |- untils |- view |- App.vue |- main.js 2. axios配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364axios.defaults.timeout = 50000const env = process.env.NODE_ENV/** * 配置测试环境 */if (env === &apos;development&apos;) &#123; axios.defaults.baseURL = &apos;/api&apos; axios.defaults.withCredentials = true&#125;axios.interceptors.request.use(config =&gt; &#123; return config&#125;, error =&gt; &#123; return Promise.reject(error)&#125;)axios.interceptors.response.use(response =&gt; &#123; return response&#125;, error =&gt; &#123; if (error.response) &#123; switch (error.response.status) &#123; case 401: // 未登录提示 &#125; &#125; return Promise.resolve(error.response)&#125;)// Get请求export function Get (url, param, headers) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.get(url, headers, &#123; params: param &#125;).then(response =&gt; &#123; resolve(response.data) &#125;, err =&gt; &#123; reject(err) &#125;).catch((error) =&gt; &#123; reject(error) &#125;) &#125;)&#125;// Post请求export function Post (url, params, headers) &#123; params = headers ? params : qs.stringify(params) return new Promise((resolve, reject) =&gt; &#123; axios.post(url, params, &#123; headers: &#123; &apos;Content-Type&apos;: headers || &apos;application/x-www-form-urlencoded;charset=utf-8&apos; &#125; &#125;) .then(response =&gt; &#123; resolve(response.data) &#125;, err =&gt; &#123; reject(err) &#125;) .catch((error) =&gt; &#123; reject(error) &#125;) &#125;)&#125; 3. 路由守卫12345678910111213141516const router = new Router(&#123; routes: routes, mode: &apos;hash&apos;&#125;)/** * 全局守卫 */router.beforeEach((to, from, next) =&gt; &#123; // 登录鉴权 next()&#125;)router.afterEach(() =&gt; &#123; window.scrollTo(0, 0)&#125;) 123456789101112131415161718&#123; path: &apos;/my_coupon&apos;, name: &apos;my_coupon&apos;, component: resolve =&gt; require([&apos;@/view/my/my-coupon&apos;], resolve), meta: &#123; title: &apos;我的优惠券&apos; &#125;, beforeEnter: (to, from, next) =&gt; &#123; /** * 判断登陆状态 */ if (sessionStorage.getItem(&apos;userinfo&apos;)) &#123; next() &#125; else &#123; next(false) &#125; &#125;&#125;","categories":[{"name":"日常笔记","slug":"日常笔记","permalink":"https://xluoyu.github.io/myblog/categories/日常笔记/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://xluoyu.github.io/myblog/tags/vue/"}]},{"title":"初探gulp","slug":"小技巧/初探gulp","date":"2019-04-15T01:30:00.000Z","updated":"2020-03-09T11:42:44.755Z","comments":true,"path":"小技巧/初探gulp/","link":"","permalink":"https://xluoyu.github.io/myblog/小技巧/初探gulp/","excerpt":"用自动化构建工具增强你的工作流程！","text":"用自动化构建工具增强你的工作流程！今天看视频的时候看都有人使用gulp来构建项目，早就听闻gulp的大名但一直没有去了解，今天做了个项目试用并记录一下gulp~ Here we go！ 首先当然是建立一个文件夹，因为要用到node，所以需要调出命令行执行 12345$ mkdir &lt;项目文件夹&gt;$ npm init/** * 创建项目，设置作者、简介之类的 / 安装一大堆npm包~ 123456789101112131415/** * 这里是这次项目用到的，也是常用的包 / &quot;devDependencies&quot;: &#123; &quot;babel-core&quot;: &quot;^6.26.3&quot;, &quot;babel-loader&quot;: &quot;7.1.2&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;, &quot;gulp&quot;: &quot;^4.0.0&quot;, &quot;gulp-connect&quot;: &quot;^5.7.0&quot;, &quot;gulp-less&quot;: &quot;^4.0.1&quot;, &quot;gulp-sass&quot;: &quot;^4.0.2&quot;, &quot;gulp-scss&quot;: &quot;^1.4.0&quot;, &quot;gulp-util&quot;: &quot;^3.0.8&quot;, &quot;webpack-stream&quot;: &quot;^5.2.1&quot; &#125; 创建gulpfile.js文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const gulp = require(&quot;gulp&quot;);const connect = require(&quot;gulp-connect&quot;);const rootPath = &quot;../www/&quot;; // 静态输出文件地址gulp.task(&quot;webpack&quot;, () =&gt; &#123; /** * 使用webpack进行js的编译打包工作 / const webpack = require(&quot;webpack-stream&quot;); const config = require(&quot;./webpack.config.js&quot;); // webpack配置文件稍后创建 return gulp.src(&quot;./js/**/*.js&quot;) .pipe(webpack(config)) .pipe(gulp.dest(&quot;../www/js&quot;)) // js文件输出地址 .pipe(connect.reload());&#125;);gulp.task(&quot;scss&quot;, () =&gt; &#123; /** * gulp-sass编译scss文件 / const scss = require(&quot;gulp-sass&quot;); return gulp.src(&quot;./scss/**/*.scss&quot;) .pipe(scss()) .pipe(gulp.dest(&quot;../www/css&quot;)) // css文件输出地址 .pipe(connect.reload());&#125;);gulp.task(&quot;watch&quot;, () =&gt; &#123; /** * 监听文件改动，监听到就执行响应任务 / gulp.watch(&quot;scss/**/*.scss&quot;, gulp.series(&quot;scss&quot;)); gulp.watch(&quot;js/**/*.js&quot;, gulp.series(&quot;webpack&quot;));&#125;);gulp.task(&quot;serve&quot;, () =&gt; &#123; /** * 使用gulp-connect创建一个服务器运行静态文件 / connect.server(&#123; root: rootPath, livereload: true, // 自动更新 port:3000 &#125;);&#125;)/** * 执行任务列表 * gulp.series -&gt; 运行任务序列 * gulp.parallel -&gt; 并行运行任务 /gulp.task(&quot;default&quot;, gulp.series(gulp.parallel(&quot;serve&quot;, &quot;watch&quot;, &quot;webpack&quot;, &quot;scss&quot;))); gulp脚本创建完了，还要创建webpack的配置文件webpack.config.js 123456789101112131415161718192021module.exports = &#123; mode: &apos;development&apos;, entry: &#123; index: &quot;./js/index&quot; &#125;, output: &#123; filename: &quot;[name].js&quot; &#125;, devtool: &quot;source-map&quot;, resolve: &#123; extensions: [&quot;.js&quot;] &#125;, module: &#123; rules: [ &#123; test: /\\.js$/, use: &quot;babel-loader&quot; &#125; ] &#125;&#125;; 展示一下完成后的项目树 12345678910111213141516项目名|├─src│ ├─js│ │ └─index.js│ ├─node_modules│ ├─scss│ │ └─main.scss│ ├─gulpfile.js│ ├─package-lock.json│ ├─pacjage.json│ └─webpack.config.js└─www ├─css ├─js └─index.html 最后使用命令行进入src目录运行gulp1234567891011121314151617181920PS E:\\练习\\项目名&gt; cd srcPS E:\\练习\\项目名\\src&gt; gulpUsing gulpfile E:\\练习\\soduku\\src\\gulpfile.jsStarting &apos;default&apos;...Starting &apos;serve&apos;...Starting &apos;watch&apos;...Starting &apos;webpack&apos;...Starting &apos;scss&apos;...Starting server...Server started http://localhost:3000LiveReload started on port 35729Running serverFinished &apos;scss&apos; after 895 msVersion: webpack 4.29.6Built at: 2019-04-15 17:10:30 Asset Size Chunks Chunk Names index.js 6.26 KiB index [emitted] indexindex.js.map 8.48 KiB index [emitted] indexEntrypoint index = index.js index.js.mapFinished &apos;webpack&apos; after 相较于webpack来说gulp比较小而美，使用的api较少也便于学习，不过在单页应用领域还是没法和webpack相比的, 所以在做多页应用时选用gulp就更为灵活 完结撒花🎉🎉🎉","categories":[{"name":"小技巧","slug":"小技巧","permalink":"https://xluoyu.github.io/myblog/categories/小技巧/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"https://xluoyu.github.io/myblog/tags/gulp/"}]},{"title":"module.exports与exports，export与export default之间的关系和区别","slug":"JavaScript/exports","date":"2019-04-11T08:30:00.000Z","updated":"2020-03-09T11:42:44.755Z","comments":true,"path":"JavaScript/exports/","link":"","permalink":"https://xluoyu.github.io/myblog/JavaScript/exports/","excerpt":"首先我们要明白一个前提，CommonJS模块规范和ES6模块规范完全是两种不同的概念。","text":"首先我们要明白一个前提，CommonJS模块规范和ES6模块规范完全是两种不同的概念。 CommonJS模块规范Node应用由模块组成，采用CommonJS模块规范。 根据这个规范，每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。 CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。123456var x = 5;var addX = function (value) &#123; return value + x;&#125;;module.exports.x = x;module.exports.addX = addX; 上面代码通过module.exports输出变量x和函数addX。 require方法用于加载模块。12345var example = require(&apos;./example.js&apos;);console.log(example.x); // 5console.log(example.addX(1)); // 6exports 与 module.exports 为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令。1var exports = module.exports; 于是我们可以直接在 exports 对象上添加方法，表示对外输出的接口，如同在module.exports上添加一样。注意，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。 ES6模块规范不同于CommonJS，ES6使用 export 和 import 来导出、导入模块。123456// profile.jsvar firstName = &apos;Michael&apos;;var lastName = &apos;Jackson&apos;;var year = 1958;export &#123;firstName, lastName, year&#125;; 需要特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。12345678910// 写法一export var m = 1;// 写法二var m = 1;export &#123;m&#125;;// 写法三var n = 1;export &#123;n as m&#125;; export default 命令使用export default命令，为模块指定默认输出。1234// export-default.jsexport default function () &#123; console.log(&apos;foo&apos;);&#125;","categories":[{"name":"小技巧","slug":"小技巧","permalink":"https://xluoyu.github.io/myblog/categories/小技巧/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://xluoyu.github.io/myblog/tags/小技巧/"}]},{"title":"JS经典问题：this、apply、bind、call","slug":"JavaScript/apply、bind、call","date":"2019-04-09T04:00:00.000Z","updated":"2020-03-09T11:42:44.740Z","comments":true,"path":"JavaScript/apply、bind、call/","link":"","permalink":"https://xluoyu.github.io/myblog/JavaScript/apply、bind、call/","excerpt":"讨论一下JS中的经典问题","text":"讨论一下JS中的经典问题 this关于this的指向一直是面试中的常考问题, 虽然现在随着ES6的普及，使用箭头函数可以轻松的解决this指向，但我们仍需要掌握它。在一些教程中看到了一句话 this 永远指向最后调用它的那个对象 由此我们可以写一些小例子112345678910var name = &apos;window&apos;function foo() &#123; console.log(name) // window&#125;(function (foo) &#123; var name = &apos;func&apos;; foo()&#125;)(foo) 最后输出window, 调用自执行函数的是window，所以再次函数中的指向就是window2 12345678910var name = &apos;window&apos;var test = &#123; &apos;name&apos;: &apos;test&apos;, foo: function() &#123; console.log(this.name) // test &#125;&#125;test.foo() 调用函数的对象是test，所以this指向test31234567891011var name = &apos;window&apos;var test = &#123; &apos;name&apos;: &apos;test&apos;, foo: function() &#123; console.log(this.name) // window &#125;&#125;var newFoo = test.foo;newFoo() 进行一点小改动，将函数foo赋值给newFoo，在window中调用，随后this指向window 改变this指向改变this指向的方法主要有 函数传参，将外部this传入到函数中 ES6中的箭头函数，继承this的指向 使用apply、bind、call 使用new操作符 apply、bind、callapply12345678910111213141516171819var name = &apos;window&apos;var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; setTimeout( function () &#123; console.log(this.name) // Cherry &#125;.apply(a),100); &#125;, func2: function () &#123; setTimeout( function () &#123; console.log(this.name) // window &#125;.apply(window),100); &#125;&#125;;a.func1()a.func2() bind12345678910111213141516171819var name = &apos;window&apos;var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; setTimeout( function () &#123; console.log(this.name) // Cherry &#125;.bind(a),100); &#125;, func2: function () &#123; setTimeout( function () &#123; console.log(this.name) // window &#125;.bind(window),100); &#125;&#125;;a.func1()a.func2() call12345678910111213141516171819var name = &apos;window&apos;var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; setTimeout( function () &#123; console.log(this.name) // Cherry &#125;.call(a),100); &#125;, func2: function () &#123; setTimeout( function () &#123; console.log(this.name) // window &#125;.call(window),100); &#125;&#125;;a.func1()a.func2() 由此可知，当我们对一个函数使用apply、bind、call时都会改变该函数的this指向，那么他们有什么区别呢 call call() 方法调用一个函数, 其具有一个指定的this值和分别地提供的参数(参数的列表)。1234567891011function Product(name, price) &#123; this.name = name; this.price = price;&#125;function Food(name, price) &#123; Product.call(this, name, price); this.category = &apos;food&apos;;&#125;console.log(new Food(&apos;cheese&apos;, 5).name); // cheese apply apply() 方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。 1234567891011var numbers = [5, 6, 2, 3, 7];var max = Math.max.apply(null, numbers);console.log(max);// expected output: 7var min = Math.min.apply(null, numbers);console.log(min);// expected output: 2 call()方法的作用和 apply() 方法类似，区别就是call()方法接受的是参数列表，而apply()方法接受的是一个参数数组。 bind bind()方法创建一个新的函数，在调用时设置this关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。1234567891011121314var module = &#123; x: 42, getX: function() &#123; return this.x; &#125;&#125;var unboundGetX = module.getX;console.log(unboundGetX());// expected output: undefinedvar boundGetX = unboundGetX.bind(module);console.log(boundGetX());// expected output: 42 apply、bind、call 总结相同之处: 改变函数体内 this 的指向 不同之处: call、apply的区别：接受参数的方式不一样。 bind：不立即执行。而apply、call 立即执行。","categories":[{"name":"JS基础深入","slug":"JS基础深入","permalink":"https://xluoyu.github.io/myblog/categories/JS基础深入/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xluoyu.github.io/myblog/tags/JavaScript/"}]},{"title":"a == 1 && a == 2 && a == 3","slug":"小技巧/a==1&&a==2","date":"2019-03-21T04:00:00.000Z","updated":"2020-03-09T11:42:44.755Z","comments":true,"path":"小技巧/a==1&&a==2/","link":"","permalink":"https://xluoyu.github.io/myblog/小技巧/a==1&&a==2/","excerpt":"输出 Hello World！123if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) &#123; console.log(&apos;Hello World!&apos;);&#125;","text":"输出 Hello World！123if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) &#123; console.log(&apos;Hello World!&apos;);&#125; 今天在掘金上看到了一个面试题。在这里记录一下 解法一看到这道题时，我的第一个想法就是进行 get劫持，使用 Object.defineProperty 来操作 12345678var val = 1Object.defineProperty(window, &apos;a&apos;, &#123; get: () =&gt; &#123; return val++ &#125;&#125;)... 对于window对象调用a时进行get劫持，返回改变后的值，是判断成立 解法二题目中使用 == 进行比较时，会进行类型的隐式转换，我们可以在这里做点文章 12345678var a = &#123; _value: 1, valueOf() &#123; let v = this._value++ return v &#125;&#125;... 或12345678var a = &#123; _value: 1, toString() &#123; let v = this._value++ return v &#125;&#125;... 在对象类型隐式转换为Number时，会先调用toString和valueOf方法，之后进行判断 解法三同样使用隐式转换来解题123456var a = [1,2,3];a.join = a.shift;if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) &#123; console.log(&apos;Hello World!&apos;);&#125; 数组隐式转换时调用join方法，使用shift替换掉join 更多解法 点击这里关于JS的隐式转换规则 点击这里","categories":[{"name":"小技巧","slug":"小技巧","permalink":"https://xluoyu.github.io/myblog/categories/小技巧/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://xluoyu.github.io/myblog/tags/小技巧/"}]},{"title":"一些常用函数","slug":"小技巧/JS常用函数","date":"2019-03-15T04:00:00.000Z","updated":"2020-03-09T11:42:44.755Z","comments":true,"path":"小技巧/JS常用函数/","link":"","permalink":"https://xluoyu.github.io/myblog/小技巧/JS常用函数/","excerpt":"一些常用函数","text":"一些常用函数 获取url地址get传参123456789/** * name =&gt; String 所需key * return =&gt; String 值 */function getQueryString(name) &#123; var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;); var r = window.location.search.substr(1).match(reg); if (r != null) return unescape(r[2]); return null;&#125; 生成随机数，规定max、minhexo1234567/** * min, max =&gt; Number * return =&gt; Number 生成随机数，包含（max，min） */function getRandomInt(min, max) &#123; return Math.floor(Math.random() * (max - min + 1)) + min;&#125; 常用正则12345678910111213/** * 手机号验证 */function validate(num) &#123; var reg = /^1[3-9]\\d&#123;9&#125;$/; return reg.test(num);&#125;;/** * 身份证正则 */var reg = /^[1-9]&#123;1&#125;[0-9]&#123;14&#125;$|^[1-9]&#123;1&#125;[0-9]&#123;16&#125;([0-9]|[xX])$/ 时间戳转换12345678910111213141516171819function pad(val, len) &#123; val = String(val); len = len || 2; while (val.length &lt; len) &#123; val = &apos;0&apos; + val; &#125; return val; &#125;function format(timeStamp) &#123; var time = new Date(timeStamp); var y = time.getFullYear(); var m = time.getMonth()+1; var d = time.getDate(); var h = time.getHours(); var mm = time.getMinutes(); var s = time.getSeconds(); return y+&apos;-&apos;+pad(m)+&apos;-&apos;+pad(d)+&apos; &apos;+pad(h)+&apos;:&apos;+pad(mm)+&apos;:&apos;+pad(s);&#125;","categories":[{"name":"小技巧","slug":"小技巧","permalink":"https://xluoyu.github.io/myblog/categories/小技巧/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://xluoyu.github.io/myblog/tags/小技巧/"}]},{"title":"Vue组件内修改UI库的样式","slug":"小技巧/组件内修改UI库的样式","date":"2019-01-24T01:30:00.000Z","updated":"2020-03-09T11:42:44.755Z","comments":true,"path":"小技巧/组件内修改UI库的样式/","link":"","permalink":"https://xluoyu.github.io/myblog/小技巧/组件内修改UI库的样式/","excerpt":"","text":"针对&lt;style scoped&gt;的情况下1.xxx[data-v-23d45f8] .xx &#123;&#125; 普通CSS环境 1.xxx &gt;&gt;&gt; .xx &#123;&#125; less/sass等预编译器 1.xxx /deep/ .xx &#123;&#125;","categories":[{"name":"小技巧","slug":"小技巧","permalink":"https://xluoyu.github.io/myblog/categories/小技巧/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://xluoyu.github.io/myblog/tags/小技巧/"}]},{"title":"动态修改最后一项样式","slug":"小技巧/自适应修改最后一项样式","date":"2019-01-22T04:00:00.000Z","updated":"2020-03-09T11:42:44.755Z","comments":true,"path":"小技巧/自适应修改最后一项样式/","link":"","permalink":"https://xluoyu.github.io/myblog/小技巧/自适应修改最后一项样式/","excerpt":"在自适应环境下，当一排li的数量不固定时，修改每排最后一个li的样式。动态修改::after样式","text":"在自适应环境下，当一排li的数量不固定时，修改每排最后一个li的样式。动态修改::after样式 问题在写代码的时候遇到了这样一个场景：需要将每一块的内容用线条隔开且最外层没有线条当然，对于以上效果我们只用css就可以实现1234567/** * CSS */li:not(:last-child)&#123; border-right: 1px solid #ccc;&#125; 这样就实现了以上的需求但我们要实现的不着这么简单的事，在有着多种多样的分辨率设备的今天，我们要使网页进行自适应，调整之后并缩小网页的效果如下这样的话在小分辨率的设备中，我们的页面就不符合需求了，那么要怎么修改呢？只能编写JS咯ο(=•ω＜=)ρ⌒☆ 思路 代码思路: 获取一排的对象数量，通过css的nth-child( Xn )设置border 获取数量的思路: 获取所有li的offsetTop，判断与第一个li的值相同的个数即为一排的对象数 代码1234567891011121314151617181920212223&lt;script&gt; var oli = document.querySelectorAll(&apos;li&apos;) var index = getIndex(oli) var getList = document.querySelectorAll(&apos;li:nth-child(&apos;+index+&apos;n)&apos;) for (var z=0; z&lt; getList.length; z++) &#123; getList[z].style.borderRight = &apos;none&apos; &#125; /** * 获取一排中的对象个数 */ function getIndex(oli) &#123; var arr = [] // 保存所有li的offsetTop var index = 0 for (var i=0; i&lt;oli.length; i++) &#123; arr[i] = oli[i].offsetTop &#125; for (var j=0; j&lt;arr.length; j++) &#123; if (arr[0] == arr[j]) index++ &#125; return index &#125;&lt;/script&gt; 实现 拓展 :after实现边框因项目的实际需求较为麻烦，边框的实现放在了li:after中 CSS代码：12345678910111213141516171819li&#123; list-style: none; width: 200px; height: 200px; background: #eee; margin-bottom: 10px; line-height: 200px; text-align: center; position: relative;&#125;li:not(:last-child):after&#123; content: &apos;&apos;; position: absolute; width: 1px; height: 100px; background: #ccc; right: 0; top: 50px;&#125; 这是再将窗口缩小又会出现问题，修改JS代码:123456789101112131415161718192021&lt;script&gt; var oli = document.querySelectorAll(&apos;li&apos;) var index = getIndex(oli) var getList = document.querySelectorAll(&apos;li:nth-child(&apos;+index+&apos;n)&apos;) for (var z=0; z&lt; getList.length; z++) &#123; getList[z].setAttribute(&apos;data-after&apos;, &apos;none&apos;) // 修改li标签上的 data-after &#125; function getIndex(oli) &#123; var arr = [] var index = 0 for (var i=0; i&lt;oli.length; i++) &#123; arr[i] = oli[i].offsetTop oli[i].setAttribute(&apos;data-after&apos;, &apos;block&apos;) // 初始化li标签上的 data-after &#125; for (var j=0; j&lt;arr.length; j++) &#123; if (arr[0] == arr[j]) index++ &#125; return index &#125;&lt;/script&gt; CSS代码123456789101112li:not(:last-child):after&#123; content: &apos;&apos;; position: absolute; width: 1px; height: 100px; background: #ccc; right: 0; top: 50px;&#125;li[data-after=&quot;none&quot;]::after&#123; display: none&#125; 最后效果","categories":[{"name":"小技巧","slug":"小技巧","permalink":"https://xluoyu.github.io/myblog/categories/小技巧/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://xluoyu.github.io/myblog/tags/小技巧/"}]},{"title":"图片懒加载","slug":"JavaScript/图片懒加载","date":"2019-01-16T04:00:00.000Z","updated":"2020-03-09T11:42:44.755Z","comments":true,"path":"JavaScript/图片懒加载/","link":"","permalink":"https://xluoyu.github.io/myblog/JavaScript/图片懒加载/","excerpt":"分析及实现图片懒加载，lazyload","text":"分析及实现图片懒加载，lazyload 为什么要用懒加载 当我们访问一个含有众多图片的页面时，它的请求量是非常巨大的，如果依赖于这些图片的加载，那么其渲染过长也将是十分漫长的，所以我们需要一种技术来分批次的进行请求加载，这样可以减轻服务器的压力，也会对页面的加载性能有十分大的提升。 原理 通常情况下，我们使用img请求图片时会将请求路径直接写在属性src中。而使用懒加载时，我们需要让其先加载一个占位图片（通常是一张加载图或logo之类的），之后我们需要定义一个属性来保存我们真实的图片地址（比如说data-src），当这张图片进入视口时就将data-src的值绑定到src中来进行请求1&lt;img src=&quot;./load.gif&quot; data-src=&quot;../image/1.png&quot;/&gt; 简单实现 先写一下dom结构 o(￣︶￣)o 123456789101112&lt;ul&gt; &lt;li&gt; &lt;img src=&quot;./image/loading.gif&quot; data-src=&quot;./image/1.jpg&quot; class=&quot;lazyload-img&quot;&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;./image/loading.gif&quot; data-src=&quot;./image/2.jpg&quot; class=&quot;lazyload-img&quot;&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;./image/loading.gif&quot; data-src=&quot;./image/3.jpg&quot; class=&quot;lazyload-img&quot;&gt; &lt;/li&gt; ......&lt;/ul&gt; 下面是JS o(￣︶￣)o 1234567891011121314151617181920function lazyload() &#123; var imgArr = document.querySelectorAll(&apos;.lazyload-img&apos;) var imgLength = imgArr.length var viewHeight = document.documentElement.clientHeight // 窗口可视高度 return function() &#123; for (var i=0; i&lt; imgLength; i++) &#123; var imgTop = imgArr[i].getBoundingClientRect().top // 元素距离视口顶部高度 // 判断条件: imgTop小于视口高度且大于等于0 if (imgTop &lt;= viewHeight &amp;&amp; imgTop &gt;= 0) &#123; // 将 data-src 的值赋给 src imgArr[i].setAttribute(&apos;src&apos;, imgArr[i].getAttribute(&apos;data-src&apos;)) &#125; &#125; &#125;&#125;var loadImg = lazyload()loadImg()window.addEventListener(&apos;scroll&apos;, loadImg) 看一下效果ο(=•ω＜=)ρ⌒☆ ⊙﹏⊙∥懒加载的大致效果是出来了，但是可以看到，滚动条在底部时刷新，上一张图片会在其顶部出现在视口中时才加载，我们可以改变一下判断条件(o゜▽゜)o☆12345678910for (var i=0; i&lt; imgLength; i++) &#123; var imgTop = imgArr[i].getBoundingClientRect().top // 元素距离视口顶部高度 var imgBottom = imgArr[i].getBoundingClientRect().bottom // 元素距离视口底部高度 // 判断条件: imgTop小于视口高度且大于等于0 或者 imgBottom小于视口高度且大于等于0 if (imgTop &lt;= viewHeight &amp;&amp; imgTop &gt;= 0 || imgBottom &lt;= viewHeight &amp;&amp; imgBottom &gt;=0) &#123; // 将 data-src 的值赋给 src imgArr[i].setAttribute(&apos;src&apos;, imgArr[i].getAttribute(&apos;data-src&apos;)) &#125; &#125; 这样在视觉方面就ok啦~ o(￣▽￣)ブ 代码优化 不断的优化是成为优雅型代码的必经之路 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—— xluoyu 以上代码存在一个性能上的bug：在所有图片加载完成之后对于滚动条的监听事件依然还在继续, 我们可以现针对这一点并加入节流进行优化 先编写一个函数setArr将获取到的dom节点变为数组形式 JS获取到的dom节点虽然有length属性，但其本身属于节点列表（NodeList），没有数组对象中的常用方法，需先将其转换为数组 1234567function setArr(domList) &#123; var arr = [] for(var i = 0, n; n = domList[i]; ++i) &#123; arr.push(n) &#125; return arr&#125; 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859function lazyload() &#123; var imgArr = setArr(document.querySelectorAll(&apos;.lazyload-img&apos;)) var imgLength = imgArr.length var viewHeight = document.documentElement.clientHeight // 窗口可视高度 return function() &#123; if (!imgLength) return // imgLength == 0 结束 for (var i=0; i&lt; imgLength;) &#123; // 移除i++ var imgTop = imgArr[i].getBoundingClientRect().top // 元素距离视口顶部高度 var imgBottom = imgArr[i].getBoundingClientRect().bottom // 元素距离视口底部高度 // 判断条件: imgTop小于视口高度且大于等于0 或者 imgBottom小于视口高度且大于等于0 if (imgTop &lt;= viewHeight &amp;&amp; imgTop &gt;= 0 || imgBottom &lt;= viewHeight &amp;&amp; imgBottom &gt;=0) &#123; // 将 data-src 的值赋给 src imgArr[i].setAttribute(&apos;src&apos;, imgArr[i].getAttribute(&apos;data-src&apos;)) // 图片展示之后在数组中将其移除 imgArr.splice(i, 1) imgLength-- &#125; else &#123; // 不满足条件 i++ &#125; &#125; &#125;&#125;/** * 节点列表改为数组 * domList -&gt; 节点列表 */function setArr(domList) &#123; var arr = [] for(var i = 0, n; n = domList[i]; ++i) &#123; arr.push(n) &#125; return arr&#125;/** * 节流 * func -&gt; 函数 * delay -&gt; 时间(毫秒) */function throttle(func, delay) &#123; var prev = Date.now() return function () &#123; var content = this var args = arguments var now = Date.now() if (now - prev &gt;= delay) &#123; func.apply(content, args) prev = Date.now() &#125; &#125;&#125;var loadImg = lazyload()loadImg()window.addEventListener(&apos;scroll&apos;, throttle(loadImg, 200)) 展示效果请戳 懒加载Demo","categories":[{"name":"JS基础深入","slug":"JS基础深入","permalink":"https://xluoyu.github.io/myblog/categories/JS基础深入/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://xluoyu.github.io/myblog/tags/性能优化/"}]},{"title":"函数的防抖与节流","slug":"JavaScript/函数的防抖与节流","date":"2019-01-12T04:00:00.000Z","updated":"2020-03-09T11:42:44.755Z","comments":true,"path":"JavaScript/函数的防抖与节流/","link":"","permalink":"https://xluoyu.github.io/myblog/JavaScript/函数的防抖与节流/","excerpt":"温故而知新~今天重新看了一下防抖和节流的文章，在这里重新整理一下","text":"温故而知新~今天重新看了一下防抖和节流的文章，在这里重新整理一下 概念函数的防抖与节流都是在处理高频率触发的函数时所用到的优化手段，在常规开发中遇见过的一些高频度场景主要有: onscroll、onsize、onMousemove、输入框的自动补全等等。当我们监听mousemove时,稍微动动鼠标就会触发上百次事件，非常影响性能，这种操作在开发中是绝对不可取的o((&gt;ω&lt; ))o，那么我们怎么去进行优化呢？我们可以提出以下两种方案： 监听mousemove时，在触发的主要函数前设置一个变量用于检测mousemove是否已经停止，如果还在触发则直接return，已经停止触发就去执行主要函数 (防抖) 监听mousemove时，我们设置一个计时器setTimeout，让它在触发mousemove的过程中，每1s（或其他时间）调用一次主要函数，从而控制调用函数的频率 (节流) 当然，我们监听mousemove可能是要做鼠标跟随之类的效果，所以我们可以使用方法2来进行优化。那么方法1所适用的场景呢？当然也有很多情况，比如在百度搜索时所体验到的自动补全功能、鼠标的多次点击等。 防抖实现防抖的主要思想就是 在触发完事件之后去调用函数12345678910111213141516171819function debounce(func, wait) &#123; var timer return function () &#123; var content = this var args = arguments // 函数传入的值(event对象) if (timer) &#123; clearTimeout(timer) &#125; timer = setTimeout(function () &#123; func.apply(content, args) &#125;, wait) &#125;&#125;function main(event) &#123; console.log(event)&#125;window.addEventListener(&apos;mousemove&apos;, debounce(main, 200)) 因为JS是单线程的，而setTimeout会将函数push到事件队列中，所以setTimeout会在事件最后触发，这也是setTimeout的黑魔法 节流实现节流的主要思想是 在一段时间内只调用一次函数实现方法主要有两种 时间戳 123456789101112function throttle(func, delay) &#123; var prev = Date.now() // 定义开始时间 return function() &#123; var content = this var args = arguments var now = Date.now() // 定义新时间 if (now - prev &gt;= delay) &#123; // 新 - 旧 &gt;= 时间间隔 func.apply(content, args) prev = Date.now() // 重新定义开始时间 &#125; &#125;&#125; 定时器 12345678910111213function throttle(func, delay) &#123; var timer return function() &#123; var content = this var args = arguments if (!timer) &#123; timer = setTimeout(function() &#123; func.apply(content, args) timer = null &#125;, delay) &#125; &#125;&#125; 总结防抖 不断的重置计时器，将所有的操作合并，最终只在最后一次操作后触发函数 节流 定义一段时间（使用时间戳或定时器），当触发时间达到设定的值时触发函数","categories":[{"name":"JS基础深入","slug":"JS基础深入","permalink":"https://xluoyu.github.io/myblog/categories/JS基础深入/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xluoyu.github.io/myblog/tags/JavaScript/"}]},{"title":"事件委托/事件代理","slug":"JavaScript/事件委托","date":"2019-01-07T04:00:00.000Z","updated":"2020-03-09T11:42:44.755Z","comments":true,"path":"JavaScript/事件委托/","link":"","permalink":"https://xluoyu.github.io/myblog/JavaScript/事件委托/","excerpt":"《JavaScript高级程序设计》：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。","text":"《JavaScript高级程序设计》：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。 事件委托/事件代理 《JavaScript高级程序设计》：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。 作用:假如我们的dom结构为 ul &gt; li*100, 每个li都有相同的click事件。如果使用for为每个li添加事件，将会影响到页面的整体运行性能，因为需要不断地与dom节点交互，随着dom操作的次数增加，页面交互准备的时间也会增多，因此在性能优化方面，较少dom操作是必不可少的优化方案。使用事件委托，只需对其父级进行操作，将大大的减少dom的交互次数，提高性能。 原理:事件委托是利用事件冒泡来实现的，在dom结构中 div &gt; ul &gt; li ，点击li出发点击事件的同时会由于事件冒泡的机制，触发ul、div上的点击事件，因此在其父级添加事件即可代替子级执行。 代码实现123456789101112131415161718192021html: &lt;ul id=&quot;ul&quot;&gt; &lt;li&gt;11&lt;/li&gt; &lt;li&gt;22&lt;/li&gt; &lt;li&gt;33&lt;/li&gt; &lt;li&gt;44&lt;/li&gt; &lt;li&gt;55&lt;/li&gt; &lt;/ul&gt;js: window.onload = function()&#123; var oUl = document.getElementById(&quot;ul&quot;); oUl.onclick = function(event)&#123; var target = event.target if (target.nodeName == &apos;LI&apos;) &#123; alert(target.innerText); &#125; &#125;&#125; JQ中的事件委托123456$(function()&#123; $(&quot;#ul&quot;).on(&quot;click&quot;,&quot;li&quot;,function(event)&#123; var target = $(event.target); target.css(&quot;background-color&quot;,&quot;red&quot;); &#125;)&#125;) 适用于的事件适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。 就写到这里吧~ 欢迎关注本小站哦~ 💪 o(￣▽￣)ブ","categories":[{"name":"JS基础深入","slug":"JS基础深入","permalink":"https://xluoyu.github.io/myblog/categories/JS基础深入/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xluoyu.github.io/myblog/tags/JavaScript/"}]},{"title":"Hello World ！","slug":"hello-world","date":"2019-01-01T02:51:20.000Z","updated":"2020-03-09T11:42:44.755Z","comments":true,"path":"hello-world/","link":"","permalink":"https://xluoyu.github.io/myblog/hello-world/","excerpt":"建站之初，先来一句 Hello World !","text":"建站之初，先来一句 Hello World ! Hello World2019年 本博客正式投入使用o(￣▽￣)ブ👏👏👏👏👏👏👏👏👏👏 先发篇文章庆祝一下","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xluoyu.github.io/myblog/tags/JavaScript/"},{"name":"html","slug":"html","permalink":"https://xluoyu.github.io/myblog/tags/html/"},{"name":"前端","slug":"前端","permalink":"https://xluoyu.github.io/myblog/tags/前端/"},{"name":"建站","slug":"建站","permalink":"https://xluoyu.github.io/myblog/tags/建站/"}]}]}