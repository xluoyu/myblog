<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xluoyu的个人博客|(。・∀・)ノ</title>
  
  <subtitle>个人技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xluoyu.cn/"/>
  <updated>2020-04-07T08:10:24.359Z</updated>
  <id>http://xluoyu.cn/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>项目优化</title>
    <link href="http://xluoyu.cn/%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0/%E5%85%B3%E4%BA%8E%E5%90%8E%E5%8F%B0%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <id>http://xluoyu.cn/日常笔记/关于后台项目的优化/</id>
    <published>2020-04-03T05:14:19.000Z</published>
    <updated>2020-04-07T08:10:24.359Z</updated>
    
    <content type="html"><![CDATA[<p>关于后台项目的点<br><a id="more"></a></p><h2 id="1-组件优化"><a href="#1-组件优化" class="headerlink" title="1. 组件优化"></a>1. 组件优化</h2><p>因为项目中含有大量的表格、筛选、弹框表单，所以对iview的一些组件进行了更贴合项目的组件封装。拿表格这一块举例，将常用到的是iview的表格组件、分页组件，还有自己实现的筛选功能组件，将这些组件混合成一个满足表格功能模块的大组件，使用的时候只需要传入表头、获取数据的事件、需要筛选的字段就可以。该组件对于这个项目来说复用性非常高。</p><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><ol><li>组件通信</li></ol><p>父子组件之间直接使用prop和事件event尽享互动传递；</p><h2 id="2-路由权限管理"><a href="#2-路由权限管理" class="headerlink" title="2. 路由权限管理"></a>2. 路由权限管理</h2><h2 id="3-第三方插件优化"><a href="#3-第三方插件优化" class="headerlink" title="3. 第三方插件优化"></a>3. 第三方插件优化</h2><p>减小lodash体积，</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于后台项目的点&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="日常笔记" scheme="http://xluoyu.cn/categories/%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="面试" scheme="http://xluoyu.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试题</title>
    <link href="http://xluoyu.cn/%E9%9D%A2%E8%AF%95%E9%A2%98/day1/"/>
    <id>http://xluoyu.cn/面试题/day1/</id>
    <published>2020-04-03T05:14:19.000Z</published>
    <updated>2020-04-05T06:08:35.305Z</updated>
    
    <content type="html"><![CDATA[<p>基础面试问题1<br><a id="more"></a></p><h2 id="1-css兼容性有哪几种处理方案"><a href="#1-css兼容性有哪几种处理方案" class="headerlink" title="1.css兼容性有哪几种处理方案"></a>1.css兼容性有哪几种处理方案</h2><p> 由于浏览器厂商太多，出品了各种浏览器，不过现在还是chrome浏览器的内核占比比较多，所以先是以chrome为主，然后去兼容IE之类的浏览器内核。</p><ol><li><p>css初始化。因为每个浏览器的css默认样式不尽相同，所以最有效的办法是将所使用到的一些样式添加上默认值，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">html, body, div, img, h1 - h6, ul, li, ol, p&#123;</span><br><span class="line">  margin: 0;</span><br><span class="line">  padding: 0;</span><br><span class="line">  font-family: &apos;微软雅黑&apos;,</span><br><span class="line">  font-size: 14px</span><br><span class="line">&#125;</span><br><span class="line">a&#123;</span><br><span class="line">  text-decoration: none</span><br><span class="line">&#125;</span><br><span class="line">img&#123;</span><br><span class="line">  border: none;</span><br><span class="line">  display: block;</span><br><span class="line">&#125;</span><br><span class="line">ul, li, ol&#123;</span><br><span class="line">  list-style: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>浏览器的私有属性。在某些css属性前添加前缀，如<code>-webkit-, -moz-</code>。<br>一个一个加这些很麻烦，所以可以引入自动化插件：Autoprefixer，在webpack或者gulp工具中加入Autoprefixer，就不用关心加前缀的事了。<h2 id="2-怎么理解margin合并-越界-塌陷"><a href="#2-怎么理解margin合并-越界-塌陷" class="headerlink" title="2.怎么理解margin合并/越界/塌陷"></a>2.怎么理解margin合并/越界/塌陷</h2>margin合并就是指两个垂直外边距相遇时，只会存在外边距较大的那个。<br>越界是父子标签都有垂直方向的margin，只会存在较大的那个。<br>要解决这种现象，可以将他们放置在不同的BFC中，比如给其中一个套上一个有<code>overflow: hidden</code>属性的标签，形成两个BFC，或者是修改margin，改为同一方向。<h2 id="3-js的继承方式有哪些"><a href="#3-js的继承方式有哪些" class="headerlink" title="3.js的继承方式有哪些"></a>3.js的继承方式有哪些</h2></li><li>原型链继承<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function parent()&#123;&#125;</span><br><span class="line">function child()&#123;&#125;</span><br><span class="line">child.prototype = new parent()</span><br></pre></td></tr></table></figure></li></ol><p>通过把父级函数赋值到子函数的原型链上实现继承<br>缺点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function parent () &#123;</span><br><span class="line">  this.type = [&apos;html&apos;, &apos;css&apos;]</span><br><span class="line">&#125;</span><br><span class="line">son1 = new child()</span><br><span class="line">son2 = new child()</span><br><span class="line">son1.type.push(&apos;vue&apos;)</span><br><span class="line">console.log(son1.type) // [&apos;html&apos;, &apos;css&apos;, &apos;vue&apos;]</span><br><span class="line">console.log(son2.type) // [&apos;html&apos;, &apos;css&apos;, &apos;vue&apos;]</span><br></pre></td></tr></table></figure><p>子函数上的原型对象都指向父函数，导致所有子函数实例化后都共享原型对象的属性和方法</p><ol start="2"><li>构造函数继承<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function parent (name) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.type = [&apos;html&apos;, &apos;css&apos;]</span><br><span class="line">&#125;</span><br><span class="line">function child (name) &#123;</span><br><span class="line">  parent.call(this, name)</span><br><span class="line">&#125;</span><br><span class="line">let son1 = new child()</span><br><span class="line">let son2 = new child()</span><br><span class="line">son1.type.push(&apos;vue&apos;)</span><br><span class="line">console.log(son1.type)  // [&apos;html&apos;, &apos;css&apos;, &apos;vue&apos;]</span><br><span class="line">console.log(son2.type)  // [&apos;html&apos;, &apos;css&apos;]</span><br></pre></td></tr></table></figure></li></ol></li></ol><p>通过构造函数call方法进行继承<br>优点： 实例化对象的独立性；还可以给实例化对象添加参数<br>缺点： call方法仅调用了父级函数的属性及方法，没有调用原型对象的方法</p><ol start="3"><li>组合继承<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function child () &#123;</span><br><span class="line">  parent.call(this)</span><br><span class="line">&#125;</span><br><span class="line">child.prototype = new parent()</span><br></pre></td></tr></table></figure></li></ol><p>把上面两个组合在一起<br>优点：基本满足了js的继承，比较常用；<br>缺点：调用了两次父级函数</p><ol start="4"><li>ES6继承<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Parent2 &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  say () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Child2 extends Parent2 &#123;</span><br><span class="line">  constructor (name) &#123;</span><br><span class="line">    super(name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let test = new Child2(&apos;test&apos;)</span><br><span class="line">test.say() // test</span><br></pre></td></tr></table></figure></li></ol><p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。</p><h2 id="4-深拷贝怎么实现"><a href="#4-深拷贝怎么实现" class="headerlink" title="4.深拷贝怎么实现"></a>4.深拷贝怎么实现</h2><p>浅拷贝：</p><blockquote><p>创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p></blockquote><p>深拷贝：</p><blockquote><p>将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象</p></blockquote><ol><li>简便法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSON.parse(JSON.stringify(obj))</span><br></pre></td></tr></table></figure></li></ol><p>这种方法是最常用的<br>原理： 用JSON.stringify将对象转成JSON字符串，再用JSON.parse()把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝<br>缺点：无法拷贝函数</p><ol start="2"><li>递归</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基础面试问题1&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="日常笔记" scheme="http://xluoyu.cn/categories/%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="面试" scheme="http://xluoyu.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>vue的基础面试题</title>
    <link href="http://xluoyu.cn/%E9%9D%A2%E8%AF%95%E9%A2%98/vue%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://xluoyu.cn/面试题/vue基础面试题/</id>
    <published>2020-04-03T05:14:19.000Z</published>
    <updated>2020-04-09T10:01:18.182Z</updated>
    
    <content type="html"><![CDATA[<p>vue的基础面试题<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vue的基础面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="日常笔记" scheme="http://xluoyu.cn/categories/%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="面试" scheme="http://xluoyu.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>关于vue的原理</title>
    <link href="http://xluoyu.cn/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%85%B3%E4%BA%8Evue%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://xluoyu.cn/面试题/关于vue的原理/</id>
    <published>2020-04-03T05:14:19.000Z</published>
    <updated>2020-04-09T05:32:07.380Z</updated>
    
    <content type="html"><![CDATA[<p>关于vue的原理<br><a id="more"></a></p><p>首先vue对于数据绑定使用的是数据劫持结合发布订阅模式，在2.6版本之前是通过<code>Object.definePrototype</code>来劫持各个属性的setter和getter方法，在数据变动时发布消息给订阅者，出发相应的回调。</p><h2 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h2><p>将需要劫持的对象进行一个递归遍历，给每个属性都加上setter和getter，这样当数据改变时就会触发他的setter，就能监听到数据变化了。然后就是实现一个消息订阅器，它可以搜集订阅者，并且触发他们的update函数。在劫持数据触发setter时调用消息订阅器的<code>notify</code>通知函数让这个数据的订阅者们都触发update</p><h2 id="Compile"><a href="#Compile" class="headerlink" title="Compile"></a>Compile</h2><p>vue实现了一个模板解析器，能够对模板中的v-bind、v-on之类的指令和表达式进行解析，将模板中的变量替换成数据，然后初始化渲染页面，并且对解析出来的变量创建订阅者和他的update方法，将订阅者添加进他所属的数据子类也就是属性订阅器中，这样在数据变化时就可以调用到这个变量的update，实现数据绑定。对于模板解析器</p><h2 id="watcher"><a href="#watcher" class="headerlink" title="watcher"></a>watcher</h2><p>Watcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是:<br>1、在自身实例化时往属性订阅器(dep)里面添加自己<br>2、自身必须有一个update()方法<br>3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于vue的原理&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="日常笔记" scheme="http://xluoyu.cn/categories/%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="面试" scheme="http://xluoyu.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Node调用微信js-sdk</title>
    <link href="http://xluoyu.cn/%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0/Node%E8%B0%83%E7%94%A8%E5%BE%AE%E4%BF%A1js-sdk/"/>
    <id>http://xluoyu.cn/日常笔记/Node调用微信js-sdk/</id>
    <published>2019-05-30T08:12:17.000Z</published>
    <updated>2020-03-09T11:42:44.755Z</updated>
    
    <content type="html"><![CDATA[<p>使用Node调用微信js-sdk，爬坑笔记<br><a id="more"></a></p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>使用node做微信后台，制作一个简单的微信转发祈福页面</p><p>效果图：<br><img src="http://cdn.xluoyu.cn/blog_wxCount1.png" width="40%" style="float: left;margin-right: 10px"><br><img src="http://cdn.xluoyu.cn/blog_wxCount2.png" alt="效果" title="效果"></p><p>主要难点：</p><ol><li>页面title的数字计数</li><li>微信Api的调用</li></ol><h2 id="1-用户数量计数"><a href="#1-用户数量计数" class="headerlink" title="1. 用户数量计数"></a>1. 用户数量计数</h2><p>使用数字来记录用户的访问量，对于计数器而言在网上可以找到很多，这里就是用了本博客中使用的 <a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子</a> 在做ip计数</p><p>页面结构如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,user-scalable=no&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;description&quot; content=&quot;转发这位考神，保佑你逢考必过！考神附体！考的全会！蒙的全对！&quot;&gt;</span><br><span class="line">  &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;!-- 引入不蒜子 --&gt;</span><br><span class="line">&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- 引入微信api --&gt;</span><br><span class="line">&lt;script src=&quot;http://res2.wx.qq.com/open/js/jweixin-1.4.0.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">html,body,img,span&#123;</span><br><span class="line">  margin: 0;</span><br><span class="line">  padding: 0;</span><br><span class="line">&#125;</span><br><span class="line">img&#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  display: block;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;img src=&quot;./img.png&quot; alt=&quot;&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 不蒜子 --&gt;</span><br><span class="line">  &lt;span id=&quot;busuanzi_value_site_pv&quot; style=&quot;display: none&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>相关JS<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var script = document.querySelectorAll(&apos;script&apos;)[0] // 引用不蒜子的script标签</span><br><span class="line">var count = 0 // 计数储存</span><br><span class="line"></span><br><span class="line">script.onload = setTitle()</span><br><span class="line">function setTitle() &#123;</span><br><span class="line">  var number = document.querySelector(&apos;#busuanzi_value_site_pv&apos;).innerHTML // 获取不蒜子计数</span><br><span class="line">  if (number) &#123;</span><br><span class="line">    document.title = &apos;我是第&apos; + number + &apos;个被考神保佑的幸运儿，逢考必过！&apos; // 修改title</span><br><span class="line">    document.body.appendChild(i);</span><br><span class="line">    count = number</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    setTimeout(setTitle, 50) // 由于需要网络请求，在获取计数之前反复验证数字</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于微信浏览器的限制，页面加载完毕之后title无法更改，需要创建一个<code>iframe</code>来处理，代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var i = document.createElement(&apos;iframe&apos;);</span><br><span class="line">    i.src = &apos;https://www.baidu.com/favicon.ico&apos;;</span><br><span class="line">    i.style.display = &apos;none&apos;;</span><br><span class="line">    i.onload = function() &#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            i.remove(); 移除</span><br><span class="line">        &#125;, 1)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在修改title后插入标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (number) &#123;</span><br><span class="line">    document.title = &apos;我是第&apos; + number + &apos;个被考神保佑的幸运儿，逢考必过！&apos; // 修改title</span><br><span class="line">    document.body.appendChild(i); // 插入iframe</span><br><span class="line">    count = number</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>easy~</p><h2 id="2-使用微信API之前"><a href="#2-使用微信API之前" class="headerlink" title="2. 使用微信API之前"></a>2. 使用微信API之前</h2><p>使用微信API就要涉及到关于微信公众号等一些账号问题，可在<a href="https://mp.weixin.qq.com/" target="_blank" rel="noopener">微信公众平台</a>自行注册。<br>如果仅用于测试，需要注册测试账号<a href="https://mp.weixin.qq.com/debug/cgi-bin/sandboxinfo" target="_blank" rel="noopener">接口测试号申请</a></p><p>有了相关账号之后就可以得到 <strong>appID</strong> 和 <strong>appsecret</strong> 用于认证，调用微信接口时还需要<em>安全域名</em><br><img src="http://cdn.xluoyu.cn/blog_wxCount3.png" alt="效果" title="效果"></p><blockquote><p><strong>坑！</strong> 不需要填写<em>http://</em>或<em>https://</em>，在本地测试也不要使用端口号，仅支持80(http)和443(https)</p></blockquote><p>之后的相关开发就可以根据<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421141115" target="_blank" rel="noopener">官方文档</a>继续进行</p><ol><li>引入js文件：<a href="http://res.wx.qq.com/open/js/jweixin-1.4.0.js" target="_blank" rel="noopener">http://res.wx.qq.com/open/js/jweixin-1.4.0.js</a> ，</li><li>前端调用后端接口，开始进行权限认证</li><li><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140183" target="_blank" rel="noopener">获取access_token</a>，并缓存</li><li>根据签名算法，获取签名，并缓存</li><li>后端将接口配置所需的相关信息返回给前端</li><li><p>注入配置信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wx.config(&#123;</span><br><span class="line">    debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。</span><br><span class="line">    appId: &apos;&apos;, // 必填，公众号的唯一标识</span><br><span class="line">    timestamp: , // 必填，生成签名的时间戳</span><br><span class="line">    nonceStr: &apos;&apos;, // 必填，生成签名的随机串</span><br><span class="line">    signature: &apos;&apos;,// 必填，签名</span><br><span class="line">    jsApiList: [] // 必填，需要使用的JS接口列表</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>通过ready接口处理成功验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.ready(function()&#123;</span><br><span class="line">    // config信息验证后会执行ready方法，所有接口调用都必须在config接口获得结果之后，config是一个客户端的异步操作，所以如果需要在页面加载时就调用相关接口，则须把相关接口放在ready函数中调用来确保正确执行。对于用户触发时才调用的接口，则可以直接调用，不需要放在ready函数中。</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-后端开发"><a href="#3-后端开发" class="headerlink" title="3. 后端开发"></a>3. 后端开发</h2><p>这里简单使用的koa2进行开发<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">... //省略</span><br><span class="line">const sha1 = require(&apos;node-sha1&apos;) // sha1加密算法</span><br><span class="line"></span><br><span class="line">// 注册公众平台/测试账号后得到的信息</span><br><span class="line">const AppID = &apos;wx12345647897987&apos;</span><br><span class="line">const APPSECRET = &apos;f0200721fa1324z2123456789&apos;</span><br><span class="line"></span><br><span class="line">// 获取access_token的地址</span><br><span class="line">const accessToken = `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=$&#123;AppID&#125;&amp;secret=$&#123;APPSECRET&#125;`</span><br><span class="line"></span><br><span class="line">// 缓存 accessToken 和 ticket</span><br><span class="line">let cache = &#123;</span><br><span class="line">  accessToken: &#123;</span><br><span class="line">    access_token: &apos;&apos;,</span><br><span class="line">    time: &apos;&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  ticket: &#123;</span><br><span class="line">    ticket: &apos;&apos;,</span><br><span class="line">    time: &apos;&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 缓存时间 2小时</span><br><span class="line">const timeRange = 2 * 60 * 60</span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line"> * 获取权限配置所需信息</span><br><span class="line"> * url =&gt; String  使用接口的页面地址</span><br><span class="line"> */</span><br><span class="line">router.get(&apos;/getData&apos;, async(ctx, next) =&gt; &#123;</span><br><span class="line">  // 获取access_token</span><br><span class="line">  const &#123; access_token &#125; = await getAccessToken().then(res =&gt; res)</span><br><span class="line">  // 获取ticket</span><br><span class="line">  const &#123; ticket &#125; = await getTicket(access_token).then(res =&gt; res)</span><br><span class="line">  // 随机字符串</span><br><span class="line">  const noncestr = Math.random().toString(36).substr(2)</span><br><span class="line">  // 时间戳 精确到秒!</span><br><span class="line">  const timestamp = Math.round(new Date().getTime()/1000).toString()</span><br><span class="line">  // 接口的请求地址，需前端传入</span><br><span class="line">  const url = ctx.query.url</span><br><span class="line">  // 组合成待加密的字符串</span><br><span class="line">  const string = `jsapi_ticket=$&#123;ticket&#125;&amp;noncestr=$&#123;noncestr&#125;&amp;timestamp=$&#123;timestamp&#125;&amp;url=$&#123;url&#125;`</span><br><span class="line">  // 使用 sha1 算法加密</span><br><span class="line">  const signature = sha1(string)</span><br><span class="line">  // 向前端返回所需信息</span><br><span class="line">  ctx.body = &#123;</span><br><span class="line">    status: 200,</span><br><span class="line">    data: &#123;</span><br><span class="line">      appId: AppID,</span><br><span class="line">      timestamp: timestamp, // 时间戳</span><br><span class="line">      noncestr: noncestr, // 随机字符串</span><br><span class="line">      signature: signature // 签名</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>由于每日获取<code>access_token</code> 和 <code>ticket</code> 的次数有限，所以需要做缓存处理，更新时间为2小时</p><p>获取access_token<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">async function getAccessToken() &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    // 判断access_token的可用时间，第一次调用函数需要设置时间，未超过两小时则直接返回</span><br><span class="line">    if (!cache.accessToken.time) &#123;</span><br><span class="line">      cache.accessToken.time = Math.round(new Date().getTime()/1000).toString()</span><br><span class="line">    &#125; else if (cache.accessToken.access_token &amp;&amp; Math.round(new Date().getTime()/1000).toString() - cache.accessToken.time &lt; timeRange) &#123;</span><br><span class="line">      resolve(cache.accessToken) // 未超过缓存时间时直接返回值</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    // 请求access_token</span><br><span class="line">    https.get(accessToken, (res) =&gt; &#123;</span><br><span class="line">      var ddd = &quot;&quot;;</span><br><span class="line">      res.on(&apos;data&apos;, (d) =&gt; &#123;</span><br><span class="line">          ddd += d;</span><br><span class="line">      &#125;);</span><br><span class="line">      res.on(&apos;end&apos;, () =&gt; &#123;</span><br><span class="line">        var obj = JSON.parse(ddd);</span><br><span class="line">        cache.accessToken.access_token = obj.access_token</span><br><span class="line">        resolve(obj)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>获取ticket<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">async function getTicket(access_token) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    // 缓存原理同上</span><br><span class="line">    if (!cache.ticket.time) &#123;</span><br><span class="line">      cache.ticket.time = Math.round(new Date().getTime()/1000).toString()</span><br><span class="line">    &#125; else if (cache.ticket.ticket &amp;&amp; Math.round(new Date().getTime()/1000).toString() - cache.ticket.time &lt; timeRange) &#123;</span><br><span class="line">      resolve(cache.ticket)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    // 根据传入的access_token，组合请求地址</span><br><span class="line">    const ticketUrl = `https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=$&#123;access_token&#125;&amp;type=jsapi`</span><br><span class="line">    // 请求ticket</span><br><span class="line">    https.get(ticketUrl, (res) =&gt; &#123;</span><br><span class="line">      var ddd = &quot;&quot;;</span><br><span class="line">      res.on(&apos;data&apos;, (d) =&gt; &#123;</span><br><span class="line">          ddd += d;</span><br><span class="line">      &#125;);</span><br><span class="line">      res.on(&apos;end&apos;, () =&gt; &#123;</span><br><span class="line">        var obj = JSON.parse(ddd);</span><br><span class="line">        cache.ticket.ticket = obj.ticket</span><br><span class="line">        resolve(obj)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-前端开发"><a href="#4-前端开发" class="headerlink" title="4. 前端开发"></a>4. 前端开发</h2><p>调用后端接口获取所需信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 传入当前页面地址</span><br><span class="line">function getData() &#123;</span><br><span class="line">  $.get(&apos;/getData&apos;, &#123;url: location.href.split(&apos;#&apos;)[0]&#125;, function (res) &#123;</span><br><span class="line">    // 成功回调</span><br><span class="line">    // 进行微信权限配置</span><br><span class="line">    wx.config(&#123;</span><br><span class="line">      debug: true,</span><br><span class="line">      appId: res.data.appId,</span><br><span class="line">      timestamp: res.data.timestamp,</span><br><span class="line">      nonceStr: res.data.noncestr,</span><br><span class="line">      signature: res.data.signature,</span><br><span class="line">      jsApiList: [&apos;updateAppMessageShareData&apos;, &apos;updateTimelineShareData&apos;]</span><br><span class="line">    &#125;)</span><br><span class="line">    setWx()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用微信Api<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function setWx() &#123;</span><br><span class="line">  wx.ready(function () &#123;</span><br><span class="line">    // 分享给朋友</span><br><span class="line">    wx.updateAppMessageShareData(&#123; </span><br><span class="line">        title: &apos;我是第&apos; + count + &apos;个被考神保佑的幸运儿，逢考必过！&apos;, // 分享标题</span><br><span class="line">        desc: &apos;转发这位考神，保佑你逢考必过！考神附体！考的全会！蒙的全对！&apos;, // 分享描述</span><br><span class="line">        link: window.location.href, // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致</span><br><span class="line">        imgUrl: &apos;http://file.rabbitpre.com/default.png&apos;, // 分享图标</span><br><span class="line">        success: function () &#123;</span><br><span class="line">          // 设置成功</span><br><span class="line">          console.log(count)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    // 分享到朋友圈</span><br><span class="line">    wx.updateTimelineShareData(&#123; </span><br><span class="line">        title: &apos;我是第&apos; + count + &apos;个被考神保佑的幸运儿，逢考必过！&apos;, // 分享标题</span><br><span class="line">        desc: &apos;转发这位考神，保佑你逢考必过！考神附体！考的全会！蒙的全对！&apos;, // 分享描述</span><br><span class="line">        link: window.location.href, // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致</span><br><span class="line">        imgUrl: &apos;http://file.rabbitpre.com/default.png&apos;, // 分享图标</span><br><span class="line">        success: function () &#123;</span><br><span class="line">          // 设置成功</span><br><span class="line">          console.log(count)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="5-遇到的坑"><a href="#5-遇到的坑" class="headerlink" title="5. 遇到的坑"></a>5. 遇到的坑</h2><ol><li>签名有误<br>主要原因：时间戳要精确到秒（<strong>不是毫秒！</strong>）</li><li>安全域名<br>主要原因：不需要写 <em>http://</em> 或 <em>https://</em>, 也不要端口！</li><li>微信开发工具的二次请求<br>将请求后端接口的函数在全局调用时会在开发工具中触发两次，但在chrome中不会，BUG原因尚不明确，我将函数的触发位置放在了修改title之后，表现为<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (number) &#123;</span><br><span class="line">  document.title = &apos;我是第&apos; + number + &apos;个被考神保佑的幸运儿，逢考必过！&apos;</span><br><span class="line">  document.body.appendChild(i);</span><br><span class="line">  count = number</span><br><span class="line">  getData()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="6-工具推荐"><a href="#6-工具推荐" class="headerlink" title="6. 工具推荐"></a>6. 工具推荐</h2><p>在公司制作这个小页面还需要涉及到微信Api、和后台交互，略有些繁琐，我们大可使用H5的一些制作工具，这里推荐<a href="https://www.rabbitpre.com/" target="_blank" rel="noopener">兔展平台</a>，其中就有这个用户计数和小卡片分享功能，不需要敲一行代码就可以制作完成，很方便~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Node调用微信js-sdk，爬坑笔记&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="日常笔记" scheme="http://xluoyu.cn/categories/%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="node.js" scheme="http://xluoyu.cn/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>实现极简版Vue(defineProptotype)</title>
    <link href="http://xluoyu.cn/JavaScript/%E5%AE%9E%E7%8E%B0%E6%9E%81%E7%AE%80%E7%89%88Vue/"/>
    <id>http://xluoyu.cn/JavaScript/实现极简版Vue/</id>
    <published>2019-05-30T08:12:17.000Z</published>
    <updated>2020-03-09T11:42:44.755Z</updated>
    
    <content type="html"><![CDATA[<p>基于definePrototype实现极简版Vue</p><p>实现功能: 数据绑定、双向绑定、methods</p><a id="more"></a><p>最终结果: <a href="/study/definePrototype.html?_blank">项目预览(可直接查看源代码)</a></p><h2 id="页面结构"><a href="#页面结构" class="headerlink" title="页面结构"></a>页面结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;p v-text=&apos;text1&apos;&gt;&lt;/p&gt;</span><br><span class="line">  &lt;p v-text=&apos;text2&apos;&gt;&lt;/p&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; v-model=&apos;text1&apos;&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; v-model=&apos;text2&apos;&gt;</span><br><span class="line">  &lt;button @click=&apos;clickBtn(hello)&apos;&gt;点击&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    text1: &apos;第一个&apos;,</span><br><span class="line">    text2: &apos;第二个&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    clickBtn(data) &#123;</span><br><span class="line">      console.log(&apos;点击输出：&apos; + data)</span><br><span class="line">      this.child()</span><br><span class="line">    &#125;,</span><br><span class="line">    child() &#123;</span><br><span class="line">      console.log(&apos;这是child&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="构建Class-Vue"><a href="#构建Class-Vue" class="headerlink" title="构建Class Vue"></a>构建Class Vue</h2><p>先写出Vue基础板块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Class Vue&#123;</span><br><span class="line">  constructor(options) &#123;</span><br><span class="line">    /**</span><br><span class="line">     *  将传入的参数绑定到Vue上</span><br><span class="line">     */</span><br><span class="line">    this.$el = document.querySelector(options.el)</span><br><span class="line">    this.$data = options.data</span><br><span class="line">    this.$methods = options.methods</span><br><span class="line"></span><br><span class="line">    this._directive = &#123;&#125; // 发布订阅库</span><br><span class="line"></span><br><span class="line">    this.Observer(this.$data)     //  数据劫持</span><br><span class="line">    this.Compile(this.$el)        //  解析模板</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Observer(data) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Compile(el) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h2><p>我们需要使用defineProptotype来重新设置data中每一项的get和set<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Observer(data) &#123;</span><br><span class="line">  for (let key in data) &#123;</span><br><span class="line">    let val = data[key]     // 储存值</span><br><span class="line">    this._directive[key] = [] // 初始化订阅器</span><br><span class="line">    /**</span><br><span class="line">     *  截取data</span><br><span class="line">     */</span><br><span class="line">    Object.definePrototype(data, key, &#123;</span><br><span class="line">      get: () =&gt; &#123;</span><br><span class="line">        return val</span><br><span class="line">      &#125;,</span><br><span class="line">      set: (newVal) =&gt; &#123;</span><br><span class="line">        if (val === newVal) return</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="解析模板"><a href="#解析模板" class="headerlink" title="解析模板"></a>解析模板</h2><p>我们要从<code>$el</code>的一层层子元素中解析出标签中绑定的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Compile(el) &#123;</span><br><span class="line">  let nodes = el.children // 获取el的所有子元素</span><br><span class="line">  for (let i=0; i &lt; nodes.length; i++) &#123;</span><br><span class="line">    let node = nodes[i]</span><br><span class="line">    // 如果第一层子元素中还有子元素，继续递归解析</span><br><span class="line">    if (node.children.length) &#123; </span><br><span class="line">      this.Compile(node)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // `v-text`</span><br><span class="line">    if (node.hasAttribute(&apos;v-text&apos;)) &#123;</span><br><span class="line">      let attrVal = node.getAttribute(&apos;v-text&apos;) // 获取值</span><br><span class="line">      /**</span><br><span class="line">       *  在发布订阅中添加一个观察者</span><br><span class="line">       *  该观察者绑定了node元素，并有一个update函数用于更新所需字段</span><br><span class="line">       */</span><br><span class="line">      this._directive[attrVal].push(new Watcher)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //  v-model</span><br><span class="line">    if (node.hasAttribute(&apos;v-model&apos;)) &#123;</span><br><span class="line">      let attrVal = node.getAttribute(&apos;v-model&apos;) // 获取值</span><br><span class="line">      /**</span><br><span class="line">       *  在发布订阅中添加一个观察者</span><br><span class="line">       */</span><br><span class="line">      this._directive[attrVal].push(new Watcher)</span><br><span class="line"></span><br><span class="line">      // 因为model是双向绑定，需要监听它的值来进行操作</span><br><span class="line">      node.addEventListener(&apos;input&apos;, (e) =&gt; &#123;</span><br><span class="line">        //  修改data中存放的值</span><br><span class="line">        this.$data[attrVal] = e.target.value</span><br><span class="line">      &#125;, false)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h2><p>观察者用以绑定含有某字段的dom元素，并提供一个update方法<br>我们改变一个dom元素的值需要<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">el.innerHTML = value</span><br><span class="line">dom元素, 操作指令,  值</span><br></pre></td></tr></table></figure></p><p>所以传入参数为</p><ol><li>el = dom元素</li><li>vm = this =&gt; 指向Vue类</li><li>exp = 操作指令</li><li>data = dom节点绑定的元素 如text1<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Class Watcher() &#123;</span><br><span class="line">  constructor(el, vm, exp, data) &#123;</span><br><span class="line">    // 绑定到类上</span><br><span class="line">    this.el = el</span><br><span class="line">    this.vm = vm</span><br><span class="line">    this.exp = exp</span><br><span class="line">    this.data = data</span><br><span class="line"></span><br><span class="line">    // 初始化更新</span><br><span class="line">    this.update()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  update() &#123;</span><br><span class="line">    this.el[exp] = this.vm.$data[this.data]</span><br><span class="line">    // el.innerHTML = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="完整代码可查看"><a href="#完整代码可查看" class="headerlink" title="完整代码可查看"></a>完整代码可查看</h2><p><a href="/study/definePrototype.html?_blank">项目预览(可直接查看源代码)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于definePrototype实现极简版Vue&lt;/p&gt;
&lt;p&gt;实现功能: 数据绑定、双向绑定、methods&lt;/p&gt;
    
    </summary>
    
      <category term="JS基础深入" scheme="http://xluoyu.cn/categories/JS%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5/"/>
    
    
      <category term="JavaScript" scheme="http://xluoyu.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>记录webapp项目开发（一）</title>
    <link href="http://xluoyu.cn/%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0/%E8%AE%B0%E5%BD%95webapp%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://xluoyu.cn/日常笔记/记录webapp项目开发（一）/</id>
    <published>2019-05-30T08:12:17.000Z</published>
    <updated>2020-03-09T11:42:44.755Z</updated>
    
    <content type="html"><![CDATA[<p>合作开发一个webapp，记录一下开发中所用到的知识点<br>一、起步<br><a id="more"></a></p><h2 id="1-项目框架"><a href="#1-项目框架" class="headerlink" title="1. 项目框架"></a>1. 项目框架</h2><p>本项目由vue全家桶 + axios + vux + less 构建</p><p>vux是基于WeUI和Vue(2.x)开发的移动端UI组件库，主要服务于微信页面<br>vux: <a href="https://doc.vux.li/zh-CN/" target="_blank" rel="noopener">https://doc.vux.li/zh-CN/</a></p><blockquote><p>注意: 在项目中引入<code>polyfill</code>以保证代码的兼容新<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/babel-polyfill/6.23.0/polyfill.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p></blockquote><p>项目结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-src</span><br><span class="line">  |-  assets</span><br><span class="line">  |-  components</span><br><span class="line">  |-  fetch</span><br><span class="line">  |     |-  axios.js        //  axios 配置文件</span><br><span class="line">  |     |-  api.js</span><br><span class="line">  |-  router</span><br><span class="line">  |-  store</span><br><span class="line">  |     |-  index.js</span><br><span class="line">  |     |-  module</span><br><span class="line">  |-  style</span><br><span class="line">  |-  untils</span><br><span class="line">  |-  view</span><br><span class="line">  |-  App.vue</span><br><span class="line">  |-  main.js</span><br></pre></td></tr></table></figure></p><h2 id="2-axios配置"><a href="#2-axios配置" class="headerlink" title="2. axios配置"></a>2. axios配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.timeout = 50000</span><br><span class="line"></span><br><span class="line">const env = process.env.NODE_ENV</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  配置测试环境</span><br><span class="line"> */</span><br><span class="line">if (env === &apos;development&apos;) &#123;</span><br><span class="line">  axios.defaults.baseURL = &apos;/api&apos;</span><br><span class="line">  axios.defaults.withCredentials  = true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">axios.interceptors.request.use(config =&gt; &#123;</span><br><span class="line">  return config</span><br><span class="line">&#125;, error =&gt; &#123;</span><br><span class="line">  return Promise.reject(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">axios.interceptors.response.use(response =&gt; &#123;</span><br><span class="line">  return response</span><br><span class="line">&#125;, error =&gt; &#123;</span><br><span class="line">  if (error.response) &#123;</span><br><span class="line">    switch (error.response.status) &#123;</span><br><span class="line">      case 401:</span><br><span class="line">        //  未登录提示</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return Promise.resolve(error.response)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// Get请求</span><br><span class="line">export function Get (url, param, headers) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    axios.get(url, headers, &#123;</span><br><span class="line">      params: param</span><br><span class="line">    &#125;).then(response =&gt; &#123;</span><br><span class="line">      resolve(response.data)</span><br><span class="line">    &#125;, err =&gt; &#123;</span><br><span class="line">      reject(err)</span><br><span class="line">    &#125;).catch((error) =&gt; &#123;</span><br><span class="line">      reject(error)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Post请求</span><br><span class="line">export function Post (url, params, headers) &#123;</span><br><span class="line">  params = headers ? params : qs.stringify(params)</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    axios.post(url, params, &#123;</span><br><span class="line">      headers: &#123;</span><br><span class="line">        &apos;Content-Type&apos;: headers || &apos;application/x-www-form-urlencoded;charset=utf-8&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">      .then(response =&gt; &#123;</span><br><span class="line">        resolve(response.data)</span><br><span class="line">      &#125;, err =&gt; &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch((error) =&gt; &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-路由守卫"><a href="#3-路由守卫" class="headerlink" title="3. 路由守卫"></a>3. 路由守卫</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const router = new Router(&#123;</span><br><span class="line">  routes: routes,</span><br><span class="line">  mode: &apos;hash&apos;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  全局守卫</span><br><span class="line"> */</span><br><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  // 登录鉴权</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.afterEach(() =&gt; &#123;</span><br><span class="line">  window.scrollTo(0, 0)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &apos;/my_coupon&apos;,</span><br><span class="line">  name: &apos;my_coupon&apos;,</span><br><span class="line">  component: resolve =&gt; require([&apos;@/view/my/my-coupon&apos;], resolve),</span><br><span class="line">  meta: &#123;</span><br><span class="line">    title: &apos;我的优惠券&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeEnter: (to, from, next) =&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     *  判断登陆状态</span><br><span class="line">     */</span><br><span class="line">    if (sessionStorage.getItem(&apos;userinfo&apos;)) &#123;</span><br><span class="line">      next()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      next(false)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;合作开发一个webapp，记录一下开发中所用到的知识点&lt;br&gt;一、起步&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="日常笔记" scheme="http://xluoyu.cn/categories/%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="http://xluoyu.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>初探gulp</title>
    <link href="http://xluoyu.cn/%E5%B0%8F%E6%8A%80%E5%B7%A7/%E5%88%9D%E6%8E%A2gulp/"/>
    <id>http://xluoyu.cn/小技巧/初探gulp/</id>
    <published>2019-04-15T01:30:00.000Z</published>
    <updated>2020-03-09T11:42:44.755Z</updated>
    
    <content type="html"><![CDATA[<p>用自动化构建工具增强你的工作流程！<br><a id="more"></a><br>今天看视频的时候看都有人使用gulp来构建项目，早就听闻gulp的大名但一直没有去了解，今天做了个项目试用并记录一下gulp~</p><p>Here we go！</p><ul><li><p>首先当然是建立一个文件夹，因为要用到node，所以需要调出命令行执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir &lt;项目文件夹&gt;</span><br><span class="line">$ npm init</span><br><span class="line">/**</span><br><span class="line"> * 创建项目，设置作者、简介之类的</span><br><span class="line"> /</span><br></pre></td></tr></table></figure></li><li><p>安装一大堆npm包~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 这里是这次项目用到的，也是常用的包</span><br><span class="line"> /</span><br><span class="line"> &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;babel-core&quot;: &quot;^6.26.3&quot;,</span><br><span class="line">    &quot;babel-loader&quot;: &quot;7.1.2&quot;,</span><br><span class="line">    &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;,</span><br><span class="line">    &quot;gulp&quot;: &quot;^4.0.0&quot;,</span><br><span class="line">    &quot;gulp-connect&quot;: &quot;^5.7.0&quot;,</span><br><span class="line">    &quot;gulp-less&quot;: &quot;^4.0.1&quot;,</span><br><span class="line">    &quot;gulp-sass&quot;: &quot;^4.0.2&quot;,</span><br><span class="line">    &quot;gulp-scss&quot;: &quot;^1.4.0&quot;,</span><br><span class="line">    &quot;gulp-util&quot;: &quot;^3.0.8&quot;,</span><br><span class="line">    &quot;webpack-stream&quot;: &quot;^5.2.1&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>创建<code>gulpfile.js</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">const gulp = require(&quot;gulp&quot;);</span><br><span class="line">const connect = require(&quot;gulp-connect&quot;);</span><br><span class="line">const rootPath = &quot;../www/&quot;; // 静态输出文件地址</span><br><span class="line"></span><br><span class="line">gulp.task(&quot;webpack&quot;, () =&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 使用webpack进行js的编译打包工作</span><br><span class="line">     /</span><br><span class="line">    const webpack = require(&quot;webpack-stream&quot;);</span><br><span class="line">    const config = require(&quot;./webpack.config.js&quot;); // webpack配置文件稍后创建</span><br><span class="line">    return gulp.src(&quot;./js/**/*.js&quot;)</span><br><span class="line">        .pipe(webpack(config))</span><br><span class="line">        .pipe(gulp.dest(&quot;../www/js&quot;)) // js文件输出地址</span><br><span class="line">        .pipe(connect.reload());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(&quot;scss&quot;, () =&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * gulp-sass编译scss文件</span><br><span class="line">     /</span><br><span class="line">    const scss = require(&quot;gulp-sass&quot;);</span><br><span class="line">    return gulp.src(&quot;./scss/**/*.scss&quot;)</span><br><span class="line">        .pipe(scss())</span><br><span class="line">        .pipe(gulp.dest(&quot;../www/css&quot;)) // css文件输出地址</span><br><span class="line">        .pipe(connect.reload());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(&quot;watch&quot;, () =&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 监听文件改动，监听到就执行响应任务</span><br><span class="line">     /</span><br><span class="line">    gulp.watch(&quot;scss/**/*.scss&quot;, gulp.series(&quot;scss&quot;));</span><br><span class="line">    gulp.watch(&quot;js/**/*.js&quot;, gulp.series(&quot;webpack&quot;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(&quot;serve&quot;, () =&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 使用gulp-connect创建一个服务器运行静态文件</span><br><span class="line">     /</span><br><span class="line">    connect.server(&#123;</span><br><span class="line">        root: rootPath,</span><br><span class="line">        livereload: true, // 自动更新</span><br><span class="line">        port:3000</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 执行任务列表</span><br><span class="line"> * gulp.series -&gt; 运行任务序列</span><br><span class="line"> * gulp.parallel -&gt; 并行运行任务</span><br><span class="line"> /</span><br><span class="line">gulp.task(&quot;default&quot;, gulp.series(gulp.parallel(&quot;serve&quot;, &quot;watch&quot;, &quot;webpack&quot;, &quot;scss&quot;)));</span><br></pre></td></tr></table></figure></li><li><p>gulp脚本创建完了，还要创建webpack的配置文件webpack.config.js</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    mode: &apos;development&apos;,</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: &quot;./js/index&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &quot;[name].js&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    devtool: &quot;source-map&quot;,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        extensions: [&quot;.js&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.js$/,</span><br><span class="line">                use: &quot;babel-loader&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>展示一下完成后的项目树</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">项目名</span><br><span class="line">|</span><br><span class="line">├─src</span><br><span class="line">│  ├─js</span><br><span class="line">│  │  └─index.js</span><br><span class="line">│  ├─node_modules</span><br><span class="line">│  ├─scss</span><br><span class="line">│  │  └─main.scss</span><br><span class="line">│  ├─gulpfile.js</span><br><span class="line">│  ├─package-lock.json</span><br><span class="line">│  ├─pacjage.json</span><br><span class="line">│  └─webpack.config.js</span><br><span class="line">└─www</span><br><span class="line">   ├─css</span><br><span class="line">   ├─js</span><br><span class="line">   └─index.html</span><br></pre></td></tr></table></figure><ul><li>最后使用命令行进入src目录运行<code>gulp</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">PS E:\练习\项目名&gt; cd src</span><br><span class="line">PS E:\练习\项目名\src&gt; gulp</span><br><span class="line">Using gulpfile E:\练习\soduku\src\gulpfile.js</span><br><span class="line">Starting &apos;default&apos;...</span><br><span class="line">Starting &apos;serve&apos;...</span><br><span class="line">Starting &apos;watch&apos;...</span><br><span class="line">Starting &apos;webpack&apos;...</span><br><span class="line">Starting &apos;scss&apos;...</span><br><span class="line">Starting server...</span><br><span class="line">Server started http://localhost:3000</span><br><span class="line">LiveReload started on port 35729</span><br><span class="line">Running server</span><br><span class="line">Finished &apos;scss&apos; after 895 ms</span><br><span class="line">Version: webpack 4.29.6</span><br><span class="line">Built at: 2019-04-15 17:10:30</span><br><span class="line">       Asset      Size  Chunks             Chunk Names</span><br><span class="line">    index.js  6.26 KiB   index  [emitted]  index</span><br><span class="line">index.js.map  8.48 KiB   index  [emitted]  index</span><br><span class="line">Entrypoint index = index.js index.js.map</span><br><span class="line">Finished &apos;webpack&apos; after</span><br></pre></td></tr></table></figure></li></ul><p>相较于webpack来说gulp比较小而美，使用的api较少也便于学习，不过在单页应用领域还是没法和webpack相比的, 所以在做多页应用时选用gulp就更为灵活</p><p>完结撒花🎉🎉🎉</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用自动化构建工具增强你的工作流程！&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="小技巧" scheme="http://xluoyu.cn/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="gulp" scheme="http://xluoyu.cn/tags/gulp/"/>
    
  </entry>
  
  <entry>
    <title>module.exports与exports，export与export default之间的关系和区别</title>
    <link href="http://xluoyu.cn/JavaScript/exports/"/>
    <id>http://xluoyu.cn/JavaScript/exports/</id>
    <published>2019-04-11T08:30:00.000Z</published>
    <updated>2020-03-09T11:42:44.755Z</updated>
    
    <content type="html"><![CDATA[<p>首先我们要明白一个前提，CommonJS模块规范和ES6模块规范完全是两种不同的概念。<br><a id="more"></a></p><h2 id="CommonJS模块规范"><a href="#CommonJS模块规范" class="headerlink" title="CommonJS模块规范"></a>CommonJS模块规范</h2><p><code>Node</code>应用由模块组成，采用CommonJS模块规范。</p><p>根据这个规范，每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</p><p>CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var x = 5;</span><br><span class="line">var addX = function (value) &#123;</span><br><span class="line">  return value + x;</span><br><span class="line">&#125;;</span><br><span class="line">module.exports.x = x;</span><br><span class="line">module.exports.addX = addX;</span><br></pre></td></tr></table></figure></p><p>上面代码通过module.exports输出变量x和函数addX。</p><p>require方法用于加载模块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var example = require(&apos;./example.js&apos;);</span><br><span class="line"></span><br><span class="line">console.log(example.x); // 5</span><br><span class="line">console.log(example.addX(1)); // 6</span><br><span class="line">exports 与 module.exports</span><br></pre></td></tr></table></figure></p><p>为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var exports = module.exports;</span><br></pre></td></tr></table></figure></p><p>于是我们可以直接在 exports 对象上添加方法，表示对外输出的接口，如同在module.exports上添加一样。注意，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。</p><h2 id="ES6模块规范"><a href="#ES6模块规范" class="headerlink" title="ES6模块规范"></a>ES6模块规范</h2><p>不同于CommonJS，ES6使用 export 和 import 来导出、导入模块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// profile.js</span><br><span class="line">var firstName = &apos;Michael&apos;;</span><br><span class="line">var lastName = &apos;Jackson&apos;;</span><br><span class="line">var year = 1958;</span><br><span class="line"></span><br><span class="line">export &#123;firstName, lastName, year&#125;;</span><br></pre></td></tr></table></figure></p><p>需要特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 写法一</span><br><span class="line">export var m = 1;</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line">var m = 1;</span><br><span class="line">export &#123;m&#125;;</span><br><span class="line"></span><br><span class="line">// 写法三</span><br><span class="line">var n = 1;</span><br><span class="line">export &#123;n as m&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="export-default-命令"><a href="#export-default-命令" class="headerlink" title="export default 命令"></a>export default 命令</h3><p>使用export default命令，为模块指定默认输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// export-default.js</span><br><span class="line">export default function () &#123;</span><br><span class="line">  console.log(&apos;foo&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先我们要明白一个前提，CommonJS模块规范和ES6模块规范完全是两种不同的概念。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="小技巧" scheme="http://xluoyu.cn/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="小技巧" scheme="http://xluoyu.cn/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>JS经典问题：this、apply、bind、call</title>
    <link href="http://xluoyu.cn/JavaScript/apply%E3%80%81bind%E3%80%81call/"/>
    <id>http://xluoyu.cn/JavaScript/apply、bind、call/</id>
    <published>2019-04-09T04:00:00.000Z</published>
    <updated>2020-03-09T11:42:44.740Z</updated>
    
    <content type="html"><![CDATA[<p>讨论一下JS中的经典问题<br><a id="more"></a></p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>关于this的指向一直是面试中的常考问题, 虽然现在随着ES6的普及，使用箭头函数可以轻松的解决this指向，但我们仍需要掌握它。在一些教程中看到了一句话</p><blockquote><p>this 永远指向最后调用它的那个对象</p></blockquote><h2 id="由此我们可以写一些小例子"><a href="#由此我们可以写一些小例子" class="headerlink" title="由此我们可以写一些小例子"></a>由此我们可以写一些小例子</h2><p>1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;window&apos;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    console.log(name) // window</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(function (foo) &#123;</span><br><span class="line">    var name = &apos;func&apos;;</span><br><span class="line">    foo()</span><br><span class="line">&#125;)(foo)</span><br></pre></td></tr></table></figure></p><p>最后输出window, 调用自执行函数的是window，所以再次函数中的指向就是window<br>2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;window&apos;</span><br><span class="line"></span><br><span class="line">var test = &#123;</span><br><span class="line">    &apos;name&apos;: &apos;test&apos;,</span><br><span class="line">    foo: function() &#123;</span><br><span class="line">        console.log(this.name) // test</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test.foo()</span><br></pre></td></tr></table></figure><p>调用函数的对象是test，所以this指向test<br>3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;window&apos;</span><br><span class="line"></span><br><span class="line">var test = &#123;</span><br><span class="line">    &apos;name&apos;: &apos;test&apos;,</span><br><span class="line">    foo: function() &#123;</span><br><span class="line">        console.log(this.name) // window</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var newFoo = test.foo;</span><br><span class="line">newFoo()</span><br></pre></td></tr></table></figure></p><p>进行一点小改动，将函数foo赋值给newFoo，在window中调用，随后this指向window</p><h2 id="改变this指向"><a href="#改变this指向" class="headerlink" title="改变this指向"></a>改变this指向</h2><p>改变this指向的方法主要有</p><ul><li>函数传参，将外部this传入到函数中</li><li>ES6中的箭头函数，继承this的指向</li><li>使用apply、bind、call</li><li>使用new操作符</li></ul><h2 id="apply、bind、call"><a href="#apply、bind、call" class="headerlink" title="apply、bind、call"></a>apply、bind、call</h2><p>apply<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;window&apos;</span><br><span class="line"></span><br><span class="line">var a = &#123;</span><br><span class="line">    name : &quot;Cherry&quot;,</span><br><span class="line"></span><br><span class="line">    func1: function () &#123;</span><br><span class="line">        setTimeout(  function () &#123;</span><br><span class="line">            console.log(this.name) // Cherry</span><br><span class="line">        &#125;.apply(a),100);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    func2: function () &#123;</span><br><span class="line">        setTimeout(  function () &#123;</span><br><span class="line">            console.log(this.name) // window</span><br><span class="line">        &#125;.apply(window),100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">a.func1()</span><br><span class="line">a.func2()</span><br></pre></td></tr></table></figure></p><p>bind<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;window&apos;</span><br><span class="line"></span><br><span class="line">var a = &#123;</span><br><span class="line">    name : &quot;Cherry&quot;,</span><br><span class="line"></span><br><span class="line">    func1: function () &#123;</span><br><span class="line">        setTimeout(  function () &#123;</span><br><span class="line">            console.log(this.name) // Cherry</span><br><span class="line">        &#125;.bind(a),100);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    func2: function () &#123;</span><br><span class="line">        setTimeout(  function () &#123;</span><br><span class="line">            console.log(this.name) // window</span><br><span class="line">        &#125;.bind(window),100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">a.func1()</span><br><span class="line">a.func2()</span><br></pre></td></tr></table></figure></p><p>call<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;window&apos;</span><br><span class="line"></span><br><span class="line">var a = &#123;</span><br><span class="line">    name : &quot;Cherry&quot;,</span><br><span class="line"></span><br><span class="line">    func1: function () &#123;</span><br><span class="line">        setTimeout(  function () &#123;</span><br><span class="line">            console.log(this.name) // Cherry</span><br><span class="line">        &#125;.call(a),100);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    func2: function () &#123;</span><br><span class="line">        setTimeout(  function () &#123;</span><br><span class="line">            console.log(this.name) // window</span><br><span class="line">        &#125;.call(window),100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">a.func1()</span><br><span class="line">a.func2()</span><br></pre></td></tr></table></figure></p><p>由此可知，当我们对一个函数使用apply、bind、call时都会改变该函数的this指向，那么他们有什么区别呢</p><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><blockquote><p>call() 方法调用一个函数, 其具有一个指定的this值和分别地提供的参数(参数的列表)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Product(name, price) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.price = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Food(name, price) &#123;</span><br><span class="line">  Product.call(this, name, price);</span><br><span class="line">  this.category = &apos;food&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(new Food(&apos;cheese&apos;, 5).name);  // cheese</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><blockquote><p>apply() 方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [5, 6, 2, 3, 7];</span><br><span class="line"></span><br><span class="line">var max = Math.max.apply(null, numbers);</span><br><span class="line"></span><br><span class="line">console.log(max);</span><br><span class="line">// expected output: 7</span><br><span class="line"></span><br><span class="line">var min = Math.min.apply(null, numbers);</span><br><span class="line"></span><br><span class="line">console.log(min);</span><br><span class="line">// expected output: 2</span><br></pre></td></tr></table></figure><blockquote><p>call()方法的作用和 apply() 方法类似，区别就是call()方法接受的是参数列表，而apply()方法接受的是一个参数数组。</p></blockquote><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><blockquote><p>bind()方法创建一个新的函数，在调用时设置this关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var module = &#123;</span><br><span class="line">  x: 42,</span><br><span class="line">  getX: function() &#123;</span><br><span class="line">    return this.x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var unboundGetX = module.getX;</span><br><span class="line">console.log(unboundGetX());</span><br><span class="line">// expected output: undefined</span><br><span class="line"></span><br><span class="line">var boundGetX = unboundGetX.bind(module);</span><br><span class="line">console.log(boundGetX());</span><br><span class="line">// expected output: 42</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="apply、bind、call-总结"><a href="#apply、bind、call-总结" class="headerlink" title="apply、bind、call 总结"></a>apply、bind、call 总结</h2><p>相同之处:</p><ul><li>改变函数体内 this 的指向</li></ul><p>不同之处: </p><ul><li>call、apply的区别：接受参数的方式不一样。</li><li>bind：不立即执行。而apply、call 立即执行。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讨论一下JS中的经典问题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JS基础深入" scheme="http://xluoyu.cn/categories/JS%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5/"/>
    
    
      <category term="JavaScript" scheme="http://xluoyu.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3</title>
    <link href="http://xluoyu.cn/%E5%B0%8F%E6%8A%80%E5%B7%A7/a==1&amp;&amp;a==2/"/>
    <id>http://xluoyu.cn/小技巧/a==1&amp;&amp;a==2/</id>
    <published>2019-03-21T04:00:00.000Z</published>
    <updated>2020-03-09T11:42:44.755Z</updated>
    
    <content type="html"><![CDATA[<p>输出 Hello World！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) &#123;</span><br><span class="line">  console.log(&apos;Hello World!&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>今天在掘金上看到了一个面试题。在这里记录一下</p><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>看到这道题时，我的第一个想法就是进行 get劫持，使用 <code>Object.defineProperty</code> 来操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var val = 1</span><br><span class="line">Object.defineProperty(window, &apos;a&apos;, &#123;</span><br><span class="line">  get: () =&gt; &#123;</span><br><span class="line">    return val++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>对于<code>window</code>对象调用<code>a</code>时进行get劫持，返回改变后的值，是判断成立</p></blockquote><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>题目中使用 == 进行比较时，会进行类型的隐式转换，我们可以在这里做点文章</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;</span><br><span class="line">  _value: 1,</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    let v = this._value++</span><br><span class="line">    return v</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;</span><br><span class="line">  _value: 1,</span><br><span class="line">  toString() &#123;</span><br><span class="line">    let v = this._value++</span><br><span class="line">    return v</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><blockquote><p>在对象类型隐式转换为Number时，会先调用<code>toString</code>和<code>valueOf</code>方法，之后进行判断</p></blockquote><h2 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h2><p>同样使用隐式转换来解题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = [1,2,3];</span><br><span class="line">a.join = a.shift;</span><br><span class="line"></span><br><span class="line">if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) &#123;</span><br><span class="line">  console.log(&apos;Hello World!&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>数组隐式转换时调用<code>join</code>方法，使用<code>shift</code>替换掉<code>join</code></p></blockquote><p>更多解法 <a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/57" target="_blank" rel="noopener">点击这里</a><br>关于JS的隐式转换规则 <a href="https://juejin.im/post/5a7172d9f265da3e3245cbca" target="_blank" rel="noopener">点击这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;输出 Hello World！&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if(a == 1 &amp;amp;&amp;amp; a == 2 &amp;amp;&amp;amp; a == 3) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.log(&amp;apos;Hello World!&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="小技巧" scheme="http://xluoyu.cn/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="小技巧" scheme="http://xluoyu.cn/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>一些常用函数</title>
    <link href="http://xluoyu.cn/%E5%B0%8F%E6%8A%80%E5%B7%A7/JS%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <id>http://xluoyu.cn/小技巧/JS常用函数/</id>
    <published>2019-03-15T04:00:00.000Z</published>
    <updated>2020-03-09T11:42:44.755Z</updated>
    
    <content type="html"><![CDATA[<p>一些常用函数<br><a id="more"></a></p><h2 id="获取url地址get传参"><a href="#获取url地址get传参" class="headerlink" title="获取url地址get传参"></a>获取url地址get传参</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * name =&gt; String 所需key</span><br><span class="line"> * return =&gt; String 值</span><br><span class="line"> */</span><br><span class="line">function getQueryString(name) &#123;</span><br><span class="line">    var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;);</span><br><span class="line">    var r = window.location.search.substr(1).match(reg);</span><br><span class="line">    if (r != null) return unescape(r[2]); return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生成随机数，规定max、min"><a href="#生成随机数，规定max、min" class="headerlink" title="生成随机数，规定max、min"></a>生成随机数，规定max、min</h2><p>hexo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * min, max =&gt; Number</span><br><span class="line"> * return =&gt; Number 生成随机数，包含（max，min）</span><br><span class="line"> */</span><br><span class="line">function getRandomInt(min, max) &#123;</span><br><span class="line">    return Math.floor(Math.random() * (max - min + 1)) + min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="常用正则"><a href="#常用正则" class="headerlink" title="常用正则"></a>常用正则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 手机号验证</span><br><span class="line"> */</span><br><span class="line">function validate(num) &#123;</span><br><span class="line">    var reg = /^1[3-9]\d&#123;9&#125;$/;</span><br><span class="line">    return reg.test(num);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 身份证正则</span><br><span class="line"> */</span><br><span class="line">var reg = /^[1-9]&#123;1&#125;[0-9]&#123;14&#125;$|^[1-9]&#123;1&#125;[0-9]&#123;16&#125;([0-9]|[xX])$/</span><br></pre></td></tr></table></figure><h2 id="时间戳转换"><a href="#时间戳转换" class="headerlink" title="时间戳转换"></a>时间戳转换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function pad(val, len) &#123;</span><br><span class="line">        val = String(val);</span><br><span class="line">        len = len || 2;</span><br><span class="line">        while (val.length &lt; len) &#123;</span><br><span class="line">            val = &apos;0&apos; + val;</span><br><span class="line">        &#125;</span><br><span class="line">        return val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">function format(timeStamp) &#123;</span><br><span class="line">    var time = new Date(timeStamp);</span><br><span class="line">    var y = time.getFullYear();</span><br><span class="line">    var m = time.getMonth()+1;</span><br><span class="line">    var d = time.getDate();</span><br><span class="line">    var h = time.getHours();</span><br><span class="line">    var mm = time.getMinutes();</span><br><span class="line">    var s = time.getSeconds();</span><br><span class="line">    return y+&apos;-&apos;+pad(m)+&apos;-&apos;+pad(d)+&apos; &apos;+pad(h)+&apos;:&apos;+pad(mm)+&apos;:&apos;+pad(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些常用函数&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="小技巧" scheme="http://xluoyu.cn/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="小技巧" scheme="http://xluoyu.cn/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Vue组件内修改UI库的样式</title>
    <link href="http://xluoyu.cn/%E5%B0%8F%E6%8A%80%E5%B7%A7/%E7%BB%84%E4%BB%B6%E5%86%85%E4%BF%AE%E6%94%B9UI%E5%BA%93%E7%9A%84%E6%A0%B7%E5%BC%8F/"/>
    <id>http://xluoyu.cn/小技巧/组件内修改UI库的样式/</id>
    <published>2019-01-24T01:30:00.000Z</published>
    <updated>2020-03-09T11:42:44.755Z</updated>
    
    <content type="html"><![CDATA[<p>针对<code>&lt;style scoped&gt;</code>的情况下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.xxx[data-v-23d45f8] .xx &#123;&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>普通CSS环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.xxx &gt;&gt;&gt; .xx &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>less/sass等预编译器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.xxx /deep/ .xx &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;针对&lt;code&gt;&amp;lt;style scoped&amp;gt;&lt;/code&gt;的情况下&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;
      
    
    </summary>
    
      <category term="小技巧" scheme="http://xluoyu.cn/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="小技巧" scheme="http://xluoyu.cn/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>动态修改最后一项样式</title>
    <link href="http://xluoyu.cn/%E5%B0%8F%E6%8A%80%E5%B7%A7/%E8%87%AA%E9%80%82%E5%BA%94%E4%BF%AE%E6%94%B9%E6%9C%80%E5%90%8E%E4%B8%80%E9%A1%B9%E6%A0%B7%E5%BC%8F/"/>
    <id>http://xluoyu.cn/小技巧/自适应修改最后一项样式/</id>
    <published>2019-01-22T04:00:00.000Z</published>
    <updated>2020-03-09T11:42:44.755Z</updated>
    
    <content type="html"><![CDATA[<p>在自适应环境下，当一排li的数量不固定时，修改每排最后一个li的样式。<br>动态修改::after样式</p><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在写代码的时候遇到了这样一个场景：<br><img src="http://cdn.xluoyu.cn/js/notLast/notLast1.png-watermark" alt="效果" title="效果"><br>需要将每一块的内容用线条隔开且最外层没有线条<br>当然，对于以上效果我们只用css就可以实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * CSS</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">li:not(:last-child)&#123;</span><br><span class="line">    border-right: 1px solid #ccc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就实现了以上的需求<br>但我们要实现的不着这么简单的事，在有着多种多样的分辨率设备的今天，我们要使网页进行自适应，调整之后并缩小网页的效果如下<br><img src="http://cdn.xluoyu.cn/js/notLast/notLast2.png-watermark" alt="效果" title="效果"><br>这样的话在小分辨率的设备中，我们的页面就不符合需求了，那么要怎么修改呢？<br>只能编写JS咯ο(=•ω＜=)ρ⌒☆</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>代码思路: 获取一排的对象数量，通过css的<code>nth-child( Xn )</code>设置<code>border</code></p><blockquote><p>获取数量的思路: 获取所有li的<code>offsetTop</code>，判断与第一个li的值相同的个数即为一排的对象数</p></blockquote></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  var oli = document.querySelectorAll(&apos;li&apos;)</span><br><span class="line"></span><br><span class="line">  var index = getIndex(oli)</span><br><span class="line">  var getList = document.querySelectorAll(&apos;li:nth-child(&apos;+index+&apos;n)&apos;)</span><br><span class="line">  for (var z=0; z&lt; getList.length; z++) &#123;</span><br><span class="line">    getList[z].style.borderRight = &apos;none&apos;</span><br><span class="line">  &#125;</span><br><span class="line">  /**</span><br><span class="line">   * 获取一排中的对象个数</span><br><span class="line">   */</span><br><span class="line">  function getIndex(oli) &#123;</span><br><span class="line">    var arr = [] // 保存所有li的offsetTop</span><br><span class="line">    var index = 0</span><br><span class="line">    for (var i=0; i&lt;oli.length; i++) &#123;</span><br><span class="line">      arr[i] = oli[i].offsetTop</span><br><span class="line">    &#125;</span><br><span class="line">    for (var j=0; j&lt;arr.length; j++) &#123;</span><br><span class="line">      if (arr[0] == arr[j]) index++</span><br><span class="line">    &#125;</span><br><span class="line">    return index</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><img src="http://cdn.xluoyu.cn/js/notLast/notLast3.png-watermark" alt="效果" title="效果"></p><h2 id="拓展-after实现边框"><a href="#拓展-after实现边框" class="headerlink" title="拓展 :after实现边框"></a>拓展 :after实现边框</h2><p>因项目的实际需求较为麻烦，边框的实现放在了<code>li:after</code>中</p><p>CSS代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">li&#123;</span><br><span class="line">    list-style: none;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background: #eee;</span><br><span class="line">    margin-bottom: 10px;</span><br><span class="line">    line-height: 200px;</span><br><span class="line">    text-align: center;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">li:not(:last-child):after&#123;</span><br><span class="line">  content: &apos;&apos;;</span><br><span class="line">  position: absolute;</span><br><span class="line">  width: 1px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background: #ccc;</span><br><span class="line">  right: 0;</span><br><span class="line">  top: 50px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://cdn.xluoyu.cn/js/notLast/notLast4.png-watermark" alt="效果" title="效果"><br>这是再将窗口缩小又会出现问题，<br>修改JS代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  var oli = document.querySelectorAll(&apos;li&apos;)</span><br><span class="line">  var index = getIndex(oli)</span><br><span class="line">  var getList = document.querySelectorAll(&apos;li:nth-child(&apos;+index+&apos;n)&apos;)</span><br><span class="line">  for (var z=0; z&lt; getList.length; z++) &#123;</span><br><span class="line">    getList[z].setAttribute(&apos;data-after&apos;, &apos;none&apos;) // 修改li标签上的 data-after</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function getIndex(oli) &#123;</span><br><span class="line">    var arr = []</span><br><span class="line">    var index = 0</span><br><span class="line">    for (var i=0; i&lt;oli.length; i++) &#123;</span><br><span class="line">      arr[i] = oli[i].offsetTop</span><br><span class="line">      oli[i].setAttribute(&apos;data-after&apos;, &apos;block&apos;) // 初始化li标签上的 data-after</span><br><span class="line">    &#125;</span><br><span class="line">    for (var j=0; j&lt;arr.length; j++) &#123;</span><br><span class="line">      if (arr[0] == arr[j]) index++</span><br><span class="line">    &#125;</span><br><span class="line">    return index</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>CSS代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">li:not(:last-child):after&#123;</span><br><span class="line">  content: &apos;&apos;;</span><br><span class="line">  position: absolute;</span><br><span class="line">  width: 1px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background: #ccc;</span><br><span class="line">  right: 0;</span><br><span class="line">  top: 50px;</span><br><span class="line">&#125;</span><br><span class="line">li[data-after=&quot;none&quot;]::after&#123;</span><br><span class="line">  display: none</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后效果<br><img src="http://cdn.xluoyu.cn/js/notLast/notLast5.png-watermark" alt="效果" title="效果"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在自适应环境下，当一排li的数量不固定时，修改每排最后一个li的样式。&lt;br&gt;动态修改::after样式&lt;/p&gt;
    
    </summary>
    
      <category term="小技巧" scheme="http://xluoyu.cn/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="小技巧" scheme="http://xluoyu.cn/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>图片懒加载</title>
    <link href="http://xluoyu.cn/JavaScript/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    <id>http://xluoyu.cn/JavaScript/图片懒加载/</id>
    <published>2019-01-16T04:00:00.000Z</published>
    <updated>2020-03-09T11:42:44.755Z</updated>
    
    <content type="html"><![CDATA[<p>分析及实现图片懒加载，lazyload</p><a id="more"></a><h2 id="为什么要用懒加载"><a href="#为什么要用懒加载" class="headerlink" title="为什么要用懒加载"></a>为什么要用懒加载</h2><p>  当我们访问一个含有众多图片的页面时，它的请求量是非常巨大的，如果依赖于这些图片的加载，那么其渲染过长也将是十分漫长的，所以我们需要一种技术来分批次的进行请求加载，这样可以减轻服务器的压力，也会对页面的加载性能有十分大的提升。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>  通常情况下，我们使用<code>img</code>请求图片时会将请求路径直接写在属性<code>src</code>中。而使用懒加载时，我们需要让其先加载一个占位图片（通常是一张加载图或logo之类的），之后我们需要定义一个属性来保存我们真实的图片地址（比如说<code>data-src</code>），当这张图片进入视口时就将<code>data-src</code>的值绑定到<code>src</code>中来进行请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;./load.gif&quot; data-src=&quot;../image/1.png&quot;/&gt;</span><br></pre></td></tr></table></figure></p><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><p>  先写一下dom结构 o(<em>￣︶￣</em>)o<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">      &lt;img src=&quot;./image/loading.gif&quot; data-src=&quot;./image/1.jpg&quot; class=&quot;lazyload-img&quot;&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">      &lt;img src=&quot;./image/loading.gif&quot; data-src=&quot;./image/2.jpg&quot; class=&quot;lazyload-img&quot;&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">      &lt;img src=&quot;./image/loading.gif&quot; data-src=&quot;./image/3.jpg&quot; class=&quot;lazyload-img&quot;&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">  ......</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><p>  下面是JS o(<em>￣︶￣</em>)o<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function lazyload() &#123;</span><br><span class="line">  var imgArr = document.querySelectorAll(&apos;.lazyload-img&apos;)</span><br><span class="line">  var imgLength = imgArr.length</span><br><span class="line">  var viewHeight = document.documentElement.clientHeight // 窗口可视高度</span><br><span class="line"></span><br><span class="line">  return function() &#123;</span><br><span class="line">    for (var i=0; i&lt; imgLength; i++) &#123;</span><br><span class="line">      var imgTop = imgArr[i].getBoundingClientRect().top  // 元素距离视口顶部高度</span><br><span class="line"></span><br><span class="line">      // 判断条件: imgTop小于视口高度且大于等于0</span><br><span class="line">        if (imgTop &lt;= viewHeight &amp;&amp; imgTop &gt;= 0) &#123;</span><br><span class="line">          // 将 data-src 的值赋给 src</span><br><span class="line">          imgArr[i].setAttribute(&apos;src&apos;, imgArr[i].getAttribute(&apos;data-src&apos;))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var loadImg = lazyload()</span><br><span class="line">loadImg()</span><br><span class="line">window.addEventListener(&apos;scroll&apos;, loadImg)</span><br></pre></td></tr></table></figure></p><p>看一下效果ο(=•ω＜=)ρ⌒☆<br><img src="http://cdn.xluoyu.cn/js/lazyload/1.gif-watermark" alt="效果" title="效果"></p><p>⊙﹏⊙∥<br>懒加载的大致效果是出来了，但是可以看到，滚动条在底部时刷新，上一张图片会在其顶部出现在视口中时才加载，我们可以改变一下判断条件(o゜▽゜)o☆<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for (var i=0; i&lt; imgLength; i++) &#123;</span><br><span class="line">      var imgTop = imgArr[i].getBoundingClientRect().top  // 元素距离视口顶部高度</span><br><span class="line">      var imgBottom = imgArr[i].getBoundingClientRect().bottom  // 元素距离视口底部高度</span><br><span class="line"></span><br><span class="line">      // 判断条件: imgTop小于视口高度且大于等于0 或者 imgBottom小于视口高度且大于等于0</span><br><span class="line">        if (imgTop &lt;= viewHeight &amp;&amp; imgTop &gt;= 0 || imgBottom &lt;= viewHeight &amp;&amp; imgBottom &gt;=0) &#123;</span><br><span class="line">          // 将 data-src 的值赋给 src</span><br><span class="line">          imgArr[i].setAttribute(&apos;src&apos;, imgArr[i].getAttribute(&apos;data-src&apos;))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这样在视觉方面就ok啦~ o(<em>￣▽￣</em>)ブ</p><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><blockquote><p>不断的优化是成为优雅型代码的必经之路 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—— xluoyu</p></blockquote><p>以上代码存在一个性能上的bug：在所有图片加载完成之后对于滚动条的监听事件依然还在继续, 我们可以现针对这一点并加入节流进行优化</p><p>先编写一个函数<code>setArr</code>将获取到的dom节点变为数组形式 </p><blockquote><p>JS获取到的dom节点虽然有length属性，但其本身属于<strong>节点列表（NodeList）</strong>，没有数组对象中的常用方法，需先将其转换为数组</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function setArr(domList) &#123;</span><br><span class="line">    var arr = []</span><br><span class="line">    for(var i = 0, n; n = domList[i]; ++i) &#123;</span><br><span class="line">        arr.push(n)</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">function lazyload() &#123;</span><br><span class="line">  var imgArr = setArr(document.querySelectorAll(&apos;.lazyload-img&apos;))</span><br><span class="line">  var imgLength = imgArr.length</span><br><span class="line">  var viewHeight = document.documentElement.clientHeight // 窗口可视高度</span><br><span class="line"></span><br><span class="line">  return function() &#123;</span><br><span class="line">    if (!imgLength) return // imgLength == 0 结束</span><br><span class="line">    </span><br><span class="line">    for (var i=0; i&lt; imgLength;) &#123;  // 移除i++</span><br><span class="line">      var imgTop = imgArr[i].getBoundingClientRect().top  // 元素距离视口顶部高度</span><br><span class="line">      var imgBottom = imgArr[i].getBoundingClientRect().bottom  // 元素距离视口底部高度</span><br><span class="line">      // 判断条件: imgTop小于视口高度且大于等于0 或者 imgBottom小于视口高度且大于等于0</span><br><span class="line">        if (imgTop &lt;= viewHeight &amp;&amp; imgTop &gt;= 0 || imgBottom &lt;= viewHeight &amp;&amp; imgBottom &gt;=0) &#123;</span><br><span class="line">          // 将 data-src 的值赋给 src</span><br><span class="line">          imgArr[i].setAttribute(&apos;src&apos;, imgArr[i].getAttribute(&apos;data-src&apos;))</span><br><span class="line">          // 图片展示之后在数组中将其移除</span><br><span class="line">          imgArr.splice(i, 1)</span><br><span class="line">          imgLength--</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          // 不满足条件</span><br><span class="line">          i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 节点列表改为数组</span><br><span class="line"> * domList -&gt; 节点列表</span><br><span class="line"> */</span><br><span class="line">function setArr(domList) &#123;</span><br><span class="line">    var arr = []</span><br><span class="line">    for(var i = 0, n; n = domList[i]; ++i) &#123;</span><br><span class="line">        arr.push(n)</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 节流</span><br><span class="line"> * func -&gt; 函数</span><br><span class="line"> * delay -&gt; 时间(毫秒)</span><br><span class="line"> */</span><br><span class="line">function throttle(func, delay) &#123;</span><br><span class="line">  var prev = Date.now()</span><br><span class="line">  return function () &#123;</span><br><span class="line">    var content = this</span><br><span class="line">    var args = arguments</span><br><span class="line">    var now = Date.now()</span><br><span class="line">    if (now - prev &gt;= delay) &#123;</span><br><span class="line">      func.apply(content, args)</span><br><span class="line">      prev = Date.now()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var loadImg = lazyload()</span><br><span class="line">loadImg()</span><br><span class="line">window.addEventListener(&apos;scroll&apos;, throttle(loadImg, 200))</span><br></pre></td></tr></table></figure><p>展示效果请戳 <a href="http://xluoyu.cn/study/lazyLoad.html?_blank">懒加载Demo</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分析及实现图片懒加载，lazyload&lt;/p&gt;
    
    </summary>
    
      <category term="JS基础深入" scheme="http://xluoyu.cn/categories/JS%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5/"/>
    
    
      <category term="性能优化" scheme="http://xluoyu.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>函数的防抖与节流</title>
    <link href="http://xluoyu.cn/JavaScript/%E5%87%BD%E6%95%B0%E7%9A%84%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"/>
    <id>http://xluoyu.cn/JavaScript/函数的防抖与节流/</id>
    <published>2019-01-12T04:00:00.000Z</published>
    <updated>2020-03-09T11:42:44.755Z</updated>
    
    <content type="html"><![CDATA[<p>温故而知新~<br>今天重新看了一下防抖和节流的文章，在这里重新整理一下</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>函数的防抖与节流都是在处理高频率触发的函数时所用到的优化手段，在常规开发中遇见过的一些高频度场景主要有: onscroll、onsize、onMousemove、输入框的自动补全等等。当我们监听<code>mousemove</code>时,稍微动动鼠标就会触发上百次事件，非常影响性能，这种操作在开发中是绝对不可取的o((&gt;ω&lt; ))o，那么我们怎么去进行优化呢？我们可以提出以下两种方案：</p><ol><li>监听<code>mousemove</code>时，在触发的主要函数前设置一个变量用于检测<code>mousemove</code>是否已经停止，如果还在触发则直接<code>return</code>，已经停止触发就去执行主要函数 (<strong>防抖</strong>)</li><li>监听<code>mousemove</code>时，我们设置一个计时器<code>setTimeout</code>，让它在触发<code>mousemove</code>的过程中，每1s（或其他时间）调用一次主要函数，从而控制调用函数的频率 (<strong>节流</strong>)</li></ol><p>当然，我们监听<code>mousemove</code>可能是要做鼠标跟随之类的效果，所以我们可以使用方法2来进行优化。那么方法1所适用的场景呢？当然也有很多情况，比如在百度搜索时所体验到的自动补全功能、鼠标的多次点击等。</p><hr><h2 id="防抖实现"><a href="#防抖实现" class="headerlink" title="防抖实现"></a>防抖实现</h2><p>防抖的主要思想就是 <strong>在触发完事件之后去调用函数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function debounce(func, wait) &#123;</span><br><span class="line">  var timer</span><br><span class="line">  return function () &#123;</span><br><span class="line">    var content = this</span><br><span class="line">    var args = arguments // 函数传入的值(event对象)</span><br><span class="line">    if (timer) &#123;</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">    &#125;</span><br><span class="line">    timer = setTimeout(function () &#123;</span><br><span class="line">      func.apply(content, args)</span><br><span class="line">    &#125;, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function main(event) &#123;</span><br><span class="line">  console.log(event)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window.addEventListener(&apos;mousemove&apos;, debounce(main, 200))</span><br></pre></td></tr></table></figure></p><p>因为JS是单线程的，而setTimeout会将函数push到事件队列中，所以setTimeout会在事件最后触发，这也是setTimeout的<strong>黑魔法</strong></p><hr><h2 id="节流实现"><a href="#节流实现" class="headerlink" title="节流实现"></a>节流实现</h2><p>节流的主要思想是 <strong>在一段时间内只调用一次函数</strong><br>实现方法主要有两种</p><ol><li><p>时间戳</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function throttle(func, delay) &#123;</span><br><span class="line">  var prev = Date.now() // 定义开始时间</span><br><span class="line">  return function() &#123;</span><br><span class="line">    var content = this</span><br><span class="line">    var args = arguments</span><br><span class="line">    var now = Date.now() // 定义新时间</span><br><span class="line">    if (now - prev &gt;= delay) &#123;  // 新 - 旧 &gt;= 时间间隔</span><br><span class="line">      func.apply(content, args)</span><br><span class="line">      prev = Date.now()  // 重新定义开始时间</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定时器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function throttle(func, delay) &#123;</span><br><span class="line">  var timer</span><br><span class="line">  return function() &#123;</span><br><span class="line">    var content = this</span><br><span class="line">    var args = arguments</span><br><span class="line">    if (!timer) &#123;</span><br><span class="line">      timer = setTimeout(function() &#123;</span><br><span class="line">        func.apply(content, args)</span><br><span class="line">        timer = null</span><br><span class="line">      &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h4 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h4><p>  不断的重置计时器，将所有的操作合并，最终只在最后一次操作后触发函数</p><h4 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h4><p>  定义一段时间（使用时间戳或定时器），当触发时间达到设定的值时触发函数</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;温故而知新~&lt;br&gt;今天重新看了一下防抖和节流的文章，在这里重新整理一下&lt;/p&gt;
    
    </summary>
    
      <category term="JS基础深入" scheme="http://xluoyu.cn/categories/JS%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5/"/>
    
    
      <category term="JavaScript" scheme="http://xluoyu.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>事件委托/事件代理</title>
    <link href="http://xluoyu.cn/JavaScript/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/"/>
    <id>http://xluoyu.cn/JavaScript/事件委托/</id>
    <published>2019-01-07T04:00:00.000Z</published>
    <updated>2020-03-09T11:42:44.755Z</updated>
    
    <content type="html"><![CDATA[<p>《JavaScript高级程序设计》：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。</p><a id="more"></a><h2 id="事件委托-事件代理"><a href="#事件委托-事件代理" class="headerlink" title="事件委托/事件代理"></a>事件委托/事件代理</h2><blockquote><p>《JavaScript高级程序设计》：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。</p></blockquote><h4 id="作用"><a href="#作用" class="headerlink" title="作用:"></a>作用:</h4><p>假如我们的dom结构为 ul &gt; li*100, 每个li都有相同的click事件。<br>如果使用for为每个li添加事件，将会影响到页面的整体运行性能，因为需要不断地与dom节点交互，随着dom操作的次数增加，页面交互准备的时间也会增多，因此在性能优化方面，较少dom操作是必不可少的优化方案。<br>使用事件委托，只需对其父级进行操作，将大大的减少dom的交互次数，提高性能。</p><hr><h4 id="原理"><a href="#原理" class="headerlink" title="原理:"></a>原理:</h4><p>事件委托是利用事件冒泡来实现的，在dom结构中 div &gt; ul &gt; li ，点击li出发点击事件的同时会由于事件冒泡的机制，触发ul、div上的点击事件，因此在其父级添加事件即可代替子级执行。</p><hr><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">html: </span><br><span class="line"></span><br><span class="line">  &lt;ul id=&quot;ul&quot;&gt;</span><br><span class="line">    &lt;li&gt;11&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;22&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;33&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;44&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;55&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">js: </span><br><span class="line"></span><br><span class="line">window.onload = function()&#123;</span><br><span class="line">  var oUl = document.getElementById(&quot;ul&quot;);</span><br><span class="line">  oUl.onclick = function(event)&#123;</span><br><span class="line">    var target = event.target</span><br><span class="line">    if (target.nodeName == &apos;LI&apos;) &#123;</span><br><span class="line">      alert(target.innerText);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JQ中的事件委托"><a href="#JQ中的事件委托" class="headerlink" title="JQ中的事件委托"></a>JQ中的事件委托</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(function()&#123;</span><br><span class="line">  $(&quot;#ul&quot;).on(&quot;click&quot;,&quot;li&quot;,function(event)&#123;</span><br><span class="line">    var target = $(event.target);</span><br><span class="line">    target.css(&quot;background-color&quot;,&quot;red&quot;);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="适用于的事件"><a href="#适用于的事件" class="headerlink" title="适用于的事件"></a>适用于的事件</h4><p>适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。</p><hr><p>就写到这里吧~ 欢迎关注本小站哦~ 💪</p><p>o(<em>￣▽￣</em>)ブ</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《JavaScript高级程序设计》：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。&lt;/p&gt;
    
    </summary>
    
      <category term="JS基础深入" scheme="http://xluoyu.cn/categories/JS%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5/"/>
    
    
      <category term="JavaScript" scheme="http://xluoyu.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Hello World ！</title>
    <link href="http://xluoyu.cn/hello-world/"/>
    <id>http://xluoyu.cn/hello-world/</id>
    <published>2019-01-01T02:51:20.000Z</published>
    <updated>2020-03-09T11:42:44.755Z</updated>
    
    <content type="html"><![CDATA[<p>建站之初，先来一句 <code>Hello World !</code></p><a id="more"></a><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><h4 id="2019年-本博客正式投入使用o-￣▽￣-ブ"><a href="#2019年-本博客正式投入使用o-￣▽￣-ブ" class="headerlink" title="2019年 本博客正式投入使用o(￣▽￣)ブ"></a>2019年 本博客正式投入使用o(<em>￣▽￣</em>)ブ</h4><p>👏👏👏👏👏👏👏👏👏👏</p><h2 id="先发篇文章庆祝一下"><a href="#先发篇文章庆祝一下" class="headerlink" title="先发篇文章庆祝一下"></a>先发篇文章庆祝一下</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;建站之初，先来一句 &lt;code&gt;Hello World !&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://xluoyu.cn/tags/JavaScript/"/>
    
      <category term="html" scheme="http://xluoyu.cn/tags/html/"/>
    
      <category term="前端" scheme="http://xluoyu.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="建站" scheme="http://xluoyu.cn/tags/%E5%BB%BA%E7%AB%99/"/>
    
  </entry>
  
</feed>
